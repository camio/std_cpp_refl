\subsection{Compile-time vs. Run-time reflection}

Run-time, dynamic reflection facilities may seem more readily
usable, but with the increasing popularity of compile-time metaprogramming,
the need for compile-time introspection (already taken care of
by \verb@type_traits@) and reflection also increases.

Also, if compile-time reflection is well supported it is relatively
easy to implement run-time or even dynamically loadable reflection
on top of it. The oposite is not true: One cannot use run-time metaobjects
or the value returned by their member functions as template parameters
or compile-time constants.

From the performance point of view, algorithms based on static
meta-data offer much more possibilities for the compiler to do
optimizations.

Thus, taking shortcuts directly to run-time reflection, without
compile-time support has obvious drawbacks.

