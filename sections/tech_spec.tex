\section{Technical Specifications}

We propose that the basic metadata describing a program written
in C++ would be made available through a set of anonymous types (classes)
defined by the compiler. These classes would describe various program
constructs like, namespaces, types, typedefs, classes, their member variables
(member data), member functions, inheritance, templates, template parameters,
enumerated values, etc.

The compiler would generate metadata for the program constructs defined
in the currently processed translation unit. Indexed sets of metaobjects,
like scope members, parameters of a function, etc. would be listed
in the order of appearance in the processed source code.

Since we want the metadata to be static, different base-level constructs
would be described by {\em "statically" different} metaobjects and thus
by {\em different} types.
For example a metaobject reflecting the global scope namespace would
be a different {\em type} than a metaobject (type) reflecting the \verb@std@
namespace, a metaobject reflecting the \verb@int@ type would
have a different type then a metaobject reflecting the \verb@double@
type, a metaobject reflecting \verb@::foo(int)@ function would
have a different type than a metaobject reflecting \verb@::foo(double)@,
function, etc.

In a manner of speaking these special types (metaobjects) become
"instances" of the meta-level concepts (static interfaces which
would not exist as concrete types, but rather only at the
"specification-level" similar for example to the iterator concepts).
This section describes a hierarchy of these metaobject concepts,
their interfaces, tag types for metaobject classification and
functions (or operators) providing access to the metaobjects.

\subsection{Specifier Concepts}

\subsection{Basic Metaobject Concepts}

This section describes the requirements that various metaobjects
need to satisfy in order to be considered models of the particular
concepts.

\subsubsection{Namespace}

Namespace is a \verb@struct@ that has the following public members:

\begin{itemize}
\item{\verb@static const char* name(void);@} returns the base name
of the namespace, without the nested name specifier. For namespace
\verb@std@ this function returns "std", for namespace \verb@foo::bar::baz@
this function returns "baz", for the global scope this functions returns ""
(an empty c-string literal).

\item{\verb@typedef@ {\em Namespace} \verb@scope;@} typedef "pointing to"
a \verb@Namespace@ reflecting the parent namespace. In the \verb@Namespace@
reflecting the global scope, this typedef points to itself.

\item{\verb@integral_constant<int,@ {\em number-of-nested-namespaces}
\verb@> namespace_count;@}

\item{\verb@Namespace namespace_i(integral_constant<int, @{\em i}
\verb@>);@} defined for $i \in \{0, 1, \dots, n-1\}$, each overload
returns a \verb@Namespace@ reflecting the {\em i}-th nested namespace.
\end{itemize}

\subsection{Basic Metaobject Categorization}

