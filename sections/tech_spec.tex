\section{Technical Specifications}

We propose that the basic metadata describing a program written
in C++ should be made available through a set of {\em anonymous} classes
defined by the compiler. These classes should describe various program
constructs like, namespaces, types, typedefs, classes, their member variables
(member data), member functions, inheritance, templates, template parameters,
enumerated values, etc.

The compiler should generate metadata for the program constructs defined
in the currently processed translation unit. Indexed sets of metaobjects,
like scope members, parameters of a function, etc. should be listed
in the order of appearance in the processed source code.

Since we want the metadata to be available at compile-time,
different base-level constructs should be reflected by
{\em "statically" different} metaobjects and thus by {\em different} types.
For example a metaobject reflecting the global scope namespace should
be a different {\em type} than a metaobject reflecting the \verb@std@
namespace, a metaobject reflecting the \verb@int@ type should
have a different type then a metaobject reflecting the \verb@double@
type, a metaobject reflecting \verb@::foo(int)@ function should
have a different type than a metaobject reflecting \verb@::foo(double)@,
function, etc.

In a manner of speaking these special types (metaobjects) should become
"instances" of the meta-level concepts (static interfaces which
should not exist as concrete types, but rather only at the
"specification-level" similar for example to the iterator concepts).
This section describes a set of metaobject concepts,
their interfaces, tag types for metaobject classification and
functions (or operators) providing access to the metaobjects.

\input{sections/tech_spec_concepts.tex}
\input{sections/tech_spec_reflection.tex}
%\input{sections/tech_spec_tagging.tex}
