\section{Introduction}
\label{section-introduction}

Reflection and reflective programming can be used
for a wide range of tasks such as implementation of serialization-like operations,
remote procedure calls, scripting, automated GUI-generation,
implementation of several software design patterns, etc.
C++ as one of the most prevalent programming languages 
lacks a standardized reflection facility.

In this paper we propose the addition of native support for
compile-time reflection to C++ and a library built
on top of the metadata provided by the compiler.

The basic static metadata provided by compile-time reflection
should be as complete as possible to be applicable in a wide
range of scenarios and allow to implement custom higher-level
static and dynamic reflection libraries and reflection-based
utilities.

The term \emph{reflection} refers to the ability of a computer program
to observe and possibly alter its own structure and/or its behavior.
This includes building new or altering the existing data structures,
doing changes to algorithms or changing the way the program code
is interpreted. Reflective programming is a particular kind
of \emph{metaprogramming}.

Reflection should follow the principle of {\em Ontological correspondence},
i.e. should {\em reflect} the base-level program constructs as closely
as possible to a reasonable level.
Reflection should not omit existing language features not invent new
ones that do not exist at the base-level.

What reflection "looks like" is thefore very language-specific.
Reflection for C++ is necessary different from reflection in Smalltalk
since these are two quite different languages.

The "reasonability" applies to the level-of-detail of the metadata
provided by reflection. It is a tradeoff between the complexity
of the reflection system and its usefulness. The "metadata" provided
by the currently standard \verb@typeid@ operator are rather simple
(which may be good), but their usefulness is very limited (which
is bad). On the other hand a fictional reflection facility that would
allow to inspect the individual instructions of a function could
be useful for some specific applications, but this system would
also be very complex to implement and use.
The proposed reflection system tries to walk a "middle ground"
and be usable in many situations without unmanagable complexity.

The advantage of using reflection is in the fact that everything
is implemented in a single programming language, and the human-written
code can be closely tied with the customizable reflection-based
code which is automatically generated by compiler metaprograms,
based on the metadata provided by reflection.

The solution proposed in this paper is based on the expirience with
\href{http://kifri.fri.uniza.sk/~chochlik/mirror-lib/html/}{\em Mirror}
reflection utilities~\cite{mirror-doc-cpp11} and with reflection-based
metaprogramming.
