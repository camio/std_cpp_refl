\subsection{Metaobject Concepts}

This section describes the requirements that various metaobjects
need to satisfy in order to be considered models of the individual
concepts.

\subsubsection{Categorization and Traits}

In order to provide means for distinguishing between regular types
and metaobjects the \verb@is_metaobject@ trait should be added
and should "return" \verb@true_type@ for metaobjects (types defined
by the compiler providing metadata) and \verb@false_type@
for non-metaobjects (native or user defined types).

The \verb@metaobject_traits@ structure should be defined to provide
categorization and additional information about the interface of metaobjects.

\begin{lstlisting}
template <typename Metaobject>
struct metaobject_traits
{
	typedef typename Metaobject::category category;

	typedef integral_constant<bool, ...> has_name;

	typedef integral_constant<bool, ...> has_scope;

	typedef integral_constant<bool, ...> is_scope;

	typedef integral_constant<bool, ...> is_class_member;

	typedef integral_constant<bool, ...> has_template;

	typedef integral_constant<bool, ...> is_template;
};
\end{lstlisting}

The meaning of the individual trait typedefs is following:

\begin{itemize}
\item{\verb@category@} Is one of the following types and specifies the category
of the metaobject:
	\begin{itemize}
		\item{\verb@specifier_tag@} indicates a {\metaobject Specifier}.

		\item{\verb@namespace_tag@} indicates a {\metaobject Namespace}.

		\item{\verb@global_scope_tag@} indicates the {\metaobject GlobalScope}.

		\item{\verb@type_tag@} indicates a {\metaobject Type}.

		\item{\verb@typedef_tag@} indicates a {\metaobject Typedef}.

		\item{\verb@class_tag@} indicates a {\metaobject Class}
		or a {\metaobject Template} class.

		\item{\verb@function_tag@} indicates a {\metaobject Function}
		or a {\metaobject Template} function.

		\item{\verb@constructor_tag@} indicates a {\metaobject Constructor}.

		\item{\verb@operator_tag@} indicates an {\metaobject Operator}.

		\item{\verb@overloaded_function_tag@} indicates an {\metaobject OverloadedFunction}.

		\item{\verb@enum_tag@} indicates an {\metaobject Enum}.

		\item{\verb@inheritance_tag@} indicates an {\metaobject Inheritance}.

		\item{\verb@constant_tag@} indicates an {\metaobject NamedConstant}.

		\item{\verb@variable_tag@} indicates a {\metaobject Variable}.

		\item{\verb@parameter_tag@} indicates a {\metaobject Parameter}.
	\end{itemize}

\item{\verb@has_name@} indicates that the reflected object is {\metaobject Named}.
By default it is defined as \verb@false_type@ unless specified otherwise in the
concept description below.

\item{\verb@has_scope@} indicates that the reflected object is {\metaobject Scoped}.
By default it is defined as \verb@false_type@ unless specified otherwise in the
concept description below.

\item{\verb@is_scope@} indicates that the reflected object is a {\metaobject Scope}.
By default it is defined as \verb@false_type@ unless specified otherwise in the
concept description below.

\item{\verb@is_class_member@} indicates that the reflected object is a {\metaobject ClassMember}.
By default it is defined as \verb@false_type@ unless specified otherwise in the
concept description below.

\item{\verb@has_template@} indicates that the reflected function or class is
a template {\metaobject Instantiation}.
By default it is defined as \verb@false_type@ unless specified otherwise in the
concept description below.

\item{\verb@is_template@} indicates that the reflected object is function or class {\metaobject Template}.
By default it is defined as \verb@false_type@ unless specified otherwise in the
concept description below.
\end{itemize}

\subsubsection{String}

{\em String} is a stateless (or monostate) \verb@class@ that represents a compile-time
character string constant storing for example a name of a type, function, namespace, etc. or the keyword
of a specifier. It allows compile-time metaprograms to examine and make decisions based
on the value of such strings. If necessary, the stored string can be returned
as a regular C-string.
See for example the Mirror's compile-time strings~\cite{mirror-ct-strings}.

One of the use-cases for these string is the filtering of scope members based on their names
if a good naming policy is consistently applied. For example: filter out all scope
members whose name starts with an underscore, or process only classes with names
starting with \verb@DB@, etc.

Types conforming to this concept must implement the following:

\begin{itemize}
	\item{\verb@static const char* c_str(void);@} static member function returning the static
	string as a regular null-terminated C-string.

	\item{\verb@static integral_constant<int, @{\em number-of-characters}\verb@> size(void);@}
	static member function returning the number of characters in the string (obviously without
	counting any terminating character).

	\item{\verb@static integral_constant<char, @{\em i-th-character}\verb@>@\\
	\verb@at(integral_constant<int, @{\em i} \verb@>);@} overloaded member function defined for 
	for $i \in \{0, 1, \dots, n-1\}$;{\em n = number-string-characters},
	each overload returning the respective character in the string.
\end{itemize}

\subsubsection{Metaobject}

{\metaobject Metaobject} is a stateless (or monostate) anonymous \verb@struct@ that provides
metadata reflecting certain program features and has the following properties:

\begin{itemize}
\item For every {\metaobject Metaobject} the \verb@is_metaobject@ trait returns \verb@true_type@.
\item For every {\metaobject Metaobject} the \verb@metaobject_traits@ structure is defined.
\item For every {\metaobject Metaobject} the {\verb@typedef Metaobject::category@} is defined
and has the same meaning as \verb@metaobject_category<Metaobject>::category@.
\end{itemize}

The exact type of a specific {\metaobject Metaobject} reflecting a specific
program feature is not defined by the standard, instances of metaobjects
should be always declared through the \verb@auto@ type specifier.

All instances (in the classical sense) of a concrete {\metaobject Metaobject} (i.e all instances 
of the concrete anonymous type satysfying the requirements of the {\metaobject Type} concept
reflecting for example the \verb@int@ type) should be equal to
the programmer.

Instances (in the classical sense) of two different metaobjects (like an instance
of the concrete anonymous type satysfying the requirements of the {\metaobject Type} concept
reflecting the \verb@int@ type and an instance 
of the concrete anonymous type satysfying the requirements of the {\metaobject Type} concept
reflecting the \verb@double@ type) of course can (and will) be different.

\begin{lstlisting}
// for all purposes these two instances of (Meta)Type
// should be equal and interchangable without any change
// to the behavior of the program
auto meta_int_1 = reflected<int>();
auto meta_int_2 = reflected<int>();
\end{lstlisting}

\subsubsection{Specifier}

{\metaobject Specifier} is a {\metaobject Metaobject}, which reflects specifiers like
\verb@const@, \verb@volatile@, \verb@private@,
\verb@protected@, \verb@public@, \verb@virtual@, etc. and has the following
requirements:

\begin{itemize}

\item{\verb@static @{\em String}\verb@ keyword(void);@} returns the keyword
of the reflected specifier. If \verb@category@ is \verb@spec_none_tag@
then \verb@keyword@ returns "" (an empty c-string).

\item{\verb@typedef Category category;@} is defined as one of the following 
types:
	\begin{itemize}
		\item{\verb@spec_none_tag@} a category for missing specifiers,
		for example a non-const member function would have a \verb@spec_none_tag@
		constness specifier or a variable with automatic storage class
		would have a \verb@spec_none_tag@ storage class specifier, etc.

		\item{\verb@spec_extern_tag@} indicates \verb@extern@ storage class / linkage.
		\item{\verb@spec_static_tag@} indicates \verb@static@ storage class / linkage.
		\item{\verb@spec_mutable_tag@} indicates \verb@mutable@ storage class / linkage.
		\item{\verb@spec_register_tag@} indicates \verb@register@ storage class / linkage.
		\item{\verb@spec_thread_local_tag@} indicates \verb@thread_local@ storage class / linkage.

		\item{\verb@spec_const_tag@} indicates \verb@const@ member functions.

		\item{\verb@spec_virtual_tag@} indicates \verb@virtual@ inheritance or function linkage.

		\item{\verb@spec_private_tag@} indicates \verb@private@ member access.
		\item{\verb@spec_protected_tag@} indicates \verb@protected@ member access.
		\item{\verb@spec_public_tag@} indicates \verb@public@ member access.

		\item{\verb@spec_class_tag@} indicates the \verb@class@ elaborated type specifier.
		\item{\verb@spec_struct_tag@} indicates the \verb@struct@ elaborated type specifier.
		\item{\verb@spec_union_tag@} indicates the \verb@union@ elaborated type specifier.
		\item{\verb@spec_enum_tag@} indicates the \verb@enum@ elaborated type specifier.
	\end{itemize}
\end{itemize}

\subsubsection{Named}

{\metaobject Named} is a {\metaobject Metaobject} reflecting program constructs,
which have a name, like namespaces, types, functions, variables, etc. and has
the following requirements:

\begin{itemize}

	\item{\verb@static @{\em String}\verb@ base_name(void);@} member function that returns the base name
	of the reflected construct, without the nested name specifier. For namespace
	\verb@std@ this function should return "std", for namespace \verb@foo::bar::baz@
	this function should return "baz", for the global scope this function
	should return "" (an empty c-string literal).\\For \verb@std::vector<int>::iterator@
	it should return "iterator". For derived and qualified types like \\
	\verb@volatile std::vector<const foo::bar::fubar*> * const *@ it should return
	"volatile vector$<$const fubar*$>$ * const *", etc. The string returned by this
	function is owned by the function and should not be freed by the caller. Alternatively 
	this member function could be called \verb@identifier@.
	

	\item \verb@metaobject_traits<Named>::has_name@ is defined as \verb@true_type@.
\end{itemize}

\subsubsection{Scoped}

{\metaobject Scoped} is a {\metaobject Metaobject} reflecting program constructs,
which are defined inside a scope (global scope, namespace, class, etc.). {\metaobject Scoped}
metaobjects have the following requirements:

\begin{itemize}
	\item{\verb@static Scope scope(void);@} static member function returning
	a {\metaobject Scope} metaobject reflecting the scope of the scoped object.
	In concrete metaobjects the result can be a {\metaobject Namespace}, {\metaobject Class},
	etc.\\The \verb@metaobject_traits<decltype(Scoped::scope())>::category@ typedef can be used to
	query the kind of the scope.

	\item \verb@metaobject_traits<Scoped>::has_scope@ is defined as \verb@true_type@.
\end{itemize}

\subsubsection{Named and Scoped}

Many of the concepts described below are specializations of both
the {\metaobject Scoped} and {\metaobject Named} concepts.
Metaobjects conforming to these concepts have the following additional
requirements:

\begin{itemize}
	\item{\verb@static @{\em String}\verb@ full_name(void);@} member function that returns the full name
	of the reflected construct, with the nested name specifier. For namespace
	\verb@std@ this function should return "std", for namespace \verb@foo::bar::baz@
	this function should return "foo::bar::baz", for the global scope this function
	should return "" (an empty c-string literal).\\For \verb@std::vector<int>::iterator@
	it should return "std::vector$<$int$>$::iterator". For derived and qualified types like\\
	\verb@volatile std::vector<const foo::bar::fubar*> * const *@ it should return
	"volatile std::vector$<$const foo::bar::fubar*$>$ * const *", etc. For some
	metaobjects this function may return the same value as the \verb@base_name@ function.
	The string returned by this function is owned by the function and should not be freed by the caller.

	\item{\verb@named_typedef@} nested member template struct defined as in
	the following pseudo-code:
	\begin{lstlisting}
	template <typename X>
	struct named_typedef
	{
		typedef X $NAME$;
	};
	\end{lstlisting}
	The \verb@$NAME$@ expression above would be replaced by the name of the reflected
	named scoped object. This structure could be used to generate new classes
	with member typedefs having the same names as the members of the scope of the named object
	reflected by this {\metaobject Named}, {\metaobject Scoped} metaobject.
	One way to combinine the \verb@$NAME$@ typedefs from various {\metaobject Named} and 
	{\metaobject Scoped} scope members into a single class would be to let the class inherit from
	multiple \verb@named_typedef@s from the metaobjects obtained by reflection.



	\item{\verb@named_mem_var@} nested member template struct defined as in
	the following pseudo-code:
	\begin{lstlisting}
	template <typename X>
	struct named_mem_var
	{
		X $NAME$;

		named_mem_var(void) = default;

		template <class Parent, class Param>
		named_mem_var(Parent& parent, Param param)
		 : $NAME$(parent, param)
		{ }
	};
	\end{lstlisting}
	The \verb@$NAME$@ expression above would be replaced by the name of the reflected
	named scoped object. This structure could be used to generate new classes
	with member variables having the same names as the members of the scope of the named object
	reflected by this {\metaobject Named}, {\metaobject Scoped} metaobject.
	The member variable \verb@$NAME$@ could be default constructible or constructible 
	from two parameters; a reference to the generated class to which the member variable
	will belong and an application specific parameter.
	One way to combinine the \verb@$NAME$@ member variables from various {\metaobject Named} and 
	{\metaobject Scoped} scope members into a single class would be to let the class inherit from
	multiple \verb@named_mem_var@s from the metaobjects obtained by reflection.
	
\end{itemize}

\subsubsection{Scope}

{\metaobject Scope} is a {\metaobject Named} and {\metaobject Scoped} metaobject,
which reflects scopes like namespaces, classes, enums, etc. {\metaobject Scope}
has the following requirements:

\begin{itemize}

	\item{\verb@static integral_constant<int,@ {\em number-of-scope-members}
	\verb@>@\\\verb@member_count(void);@} static member function returning the total number
	of various members like types, namespaces, functions, variables, etc. defined inside
	the scope reflected by a {\metaobject Scope}.

	\item{\verb@static @{\metaobject Scoped}\verb@ member(integral_constant<int, @{\em i}
	\verb@>);@} overloaded member function defined
	for $i \in \{0, 1, \dots, n-1\}$;{\em n = number-of-scope-members},
	each overload returns a different {\metaobject Scoped} metaobject reflecting the {\em i}-th member
	defined inside the scope reflected by a {\metaobject Scope}.
	In concrete metaobjects reflecting various kinds of scopes the \verb@member(...)@ function
	can return metaobjects like {\metaobject Namespace}, ({\metaobject ClassMember}) {\metaobject Variable},
	({\metaobject ClassMember}) {\metaobject OverloadedFunction}, {\metaobject Typedef},
	{\metaobject Enum}, etc.

	\item \verb@metaobject_traits<Scope>::is_scope@ is defined as \verb@true_type@.
\end{itemize}

\subsubsection{Namespace}

{\metaobject Namespace} is a {\metaobject Scope} with the following requirements:

\begin{itemize}
	\item \verb@metaobject_traits<Namespace>::category@ is defined as
	\verb@namespace_tag@.
\end{itemize}

\subsubsection{GlobalScope}

{\metaobject GlobalScope} is a {\metaobject Namespace} reflecting the global scope
and requires the following:

\begin{itemize}
	\item \verb@metaobject_traits<GlobalScope>::category@ is defined as
	\verb@global_scope_tag@.
\end{itemize}

\subsubsection{Type}

{\metaobject Type} is a {\metaobject Named} and {\metaobject Scoped} metaobject which
has the following requirements:

\begin{itemize}
	\item{\verb@typedef @{\em original-type}\verb@ original_type;@} member typedef
	defined as the original type reflected by the {\metaobject Type}.

	\item \verb@metaobject_traits<Type>::category@ is defined as \verb@type_tag@.
\end{itemize}

The \verb@is_template@ typedef in \verb@metaobject_traits@ changes the requirements
in the concepts derived from {\metaobject Type}.

\subsubsection{Typedef}

{\metaobject Typedef} is a {\metaobject Type} metaobject that reflects typedefs,
i.e. types that were defined as alternate names for another types.
{\metaobject Typedef} has the following requirements:

\begin{itemize}
	\item{\verb@static @{\metaobject Type}\verb@ type(void);@} static member function
	returning a {\metaobject Type} reflecting the "source" type of the typedef.
	In concrete {\metaobject Typedef} metaobjects \verb@type@ can return a 
	{\metaobject Type}, {\metaobject Class}, {\metaobject Enum} or {\metaobject Typedef}.

	\item \verb@metaobject_traits<Typedef>::category@ is defined as \verb@typedef_tag@.
\end{itemize}

\subsubsection{Class}

{\metaobject Class} is a {\metaobject Type} and a {\metaobject Scope} that reflects
an elaborated type (class, struct, union) or a class template.
{\metaobject Class} has the following requirements, but
the \verb@is_template@ typedef in the \verb@metaobject_traits@ changes the requirements
inherited from the {\metaobject Type} concept as described below.

\begin{itemize}
	\item{\verb@static @{\metaobject Specifier}\verb@ elaborated_type(void);@}
	static member function returning a {\metaobject Specifier} reflecting the elaborated
	type specifier used to define the class (\verb@class@, \verb@struct@, \verb@union@).

	\item{\verb@static integral_constant<int,@ {\em number-of-base-classes}
	\verb@>@\\\verb@base_class_count(void);@} static member function returning the total number
	of base classes that the class reflected by {\metaobject Class} inherits from.

	\item{\verb@static @{\metaobject Inheritance}\verb@ base_class(integral_constant<int, @{\em i}
	\verb@>);@} overloaded member function defined
	for $i \in \{0, 1, \dots, n-1\}$; {\em n = number-of-base-classes},
	each overload returns a different {\metaobject Inheritance} metaobject reflecting the inheritance
	of the {\em i}-th base class of the class reflected by {\metaobject Class}.

	\item \verb@metaobject_traits<Class>::category@ is defined as \verb@class_tag@.
\end{itemize}

If \verb@metaobject_traits<Class>::is_template@ is \verb@true_type@ it indicates 
that the reflected program feature is not a regular class, but a class template.
In such case the \verb@original_type@ typedef inherited from {\metaobject Type}
is not defined.

\subsubsection{Function}

{\metaobject Function} is a {\metaobject Scope} metaobject that reflects a function
or a function template and requires the following (the requirements are influenced
by the \verb@metaobject_traits<Function>::is_template@ typedef as described below):

\begin{itemize}
	\item{\verb@static @{\metaobject Specifier}\verb@ linkage(void);@} static member function returning
	a {\metaobject Specifier} reflecting the linkage specifier of the function.

	\item{\verb@static @{\metaobject Type}\verb@ result_type(void);@} static member function returning
	a {\metaobject Type} reflecting the result type of the function.

	\item{\verb@static integral_constant<int,@ {\em number-of-parameters}
	\verb@>@\\\verb@parameter_count(void);@} static member function returning the total number
	of parameters of the function reflected by {\metaobject Function}.

	\item{\verb@static @{\metaobject Parameter}\verb@ parameter(integral_constant<int, @{\em i}
	\verb@>);@} overloaded member function defined
	for $i \in \{0, 1, \dots, n-1\}$; {\em n = number-of-parameters},
	each overload returns a different {\metaobject Parameter} metaobject reflecting the {\em i}-th parameter
	of the function reflected by {\metaobject Function}.

	\item{\verb@static integral_constant<bool, @ {\em true-or-false}\verb@> throw_limited(void);@}
	static member function indicating whether the reflected function has only a limited list of exceptions
	that it can throw. If the reflected function was declared with the \verb@throw@ exception specification
	(either empty or with a list of exception types) then \verb@throw_limited@ returns
	\verb@true_type@, otherwise if the function can throw any exception, \verb@throw_limited@ returns \verb@false_type@.
	If \verb@true_type@ is returned, then the \verb@exception_count@ and \verb@exception@ functions
	can be used to traverse the list of exception types that the reflected function is allowed
	to throw.

	\item{\verb@static integral_constant<int,@ {\em number-of-exceptions}
	\verb@>@\\\verb@exception_count(void);@} static member function returning either the total number
	of exceptions that the function reflected by {\metaobject Function} can throw or returning
	\verb@integral_constant<int, -1>@. The result type of this function depends on the result
	of the \verb@throw_limited@ member function. If \verb@throw_limited@ returns \verb@true_type@
	then the actual number of allowed exception types is returned. If \verb@throw_limited@ returns
	\verb@false_type@ then \verb@integral_constant<int, -1>@ is returned to indicate that
	the reflected function can throw anything.

	\item{\verb@static @{\metaobject Type}\verb@ exception(integral_constant<int, @{\em i}
	\verb@>);@} overloaded member function defined
	for $i \in \{0, 1, \dots, n-1\}$; {\em n = number-of-exceptions},
	each overload returns a different {\metaobject Type} metaobject reflecting the {\em i}-th exception
	from the explicit exception specification of the function reflected by {\metaobject Function}.

	\item \verb@metaobject_traits<Function>::category@ is defined as \verb@function_tag@.
\end{itemize}

If \verb@metaobject_traits<Function>::is_template@ is defined as \verb@false_type@
i.e. the reflected feature is not a template but a regular function then the following is also
required:

\begin{itemize}
	\item{\verb@static inline ResultType::original_type call(@ {\em parameters\dots}\verb@);@}
	static inline member function with the same return value type and the same number
	and type of parameters as the original function reflected by {\metaobject Function}.
	Calls to this function should be replaced with the call of the reflected function
	with the arguments passed to \verb@call@. Additionaly if the reflected function is

	a member function, then the first of the {\em parameters} of \verb@call@ should be
	a reference to the class where the member function is defined and should be used
	as the \verb@this@ argument when calling the member function. If the member function
	is declared as \verb@const@ then the reference to the class should also be \verb@const@.
\end{itemize}

If \verb@metaobject_traits<Function>::is_class_member@ is defined as \verb@true_type@
i.e. the reflected is a member function and not a free function or lambda function,
then the following is also required:

\begin{itemize}
	\item{\verb@static @ {\metaobject Specifier} \verb@ constness(void);@} static member function
	returning  the constness {\metaobject Specifier} reflecting the constness
	of the member functions.

	\item{\verb@static integral_constant<bool,@ {\em true-or-false}\verb@> is_pure(void);@}
	static inline member function that returns \verb@true_type@ or \verb@false_type@ indicating
	whether the reflected member function is a {\em pure} virtual function. For non-virtual
	functions it always returns \verb@false_type@.
\end{itemize}

{\metaobject Function} metaobjects are {\em not} direct members of scopes. Instead,
all functions with the same name (even those that are not overloaded) in a specific scope
are grouped into a {\metaobject OverloadedFunction}. Individual overloaded {\metaobject Function}s
in the group can be obtained through the interface of {\metaobject OverloadedFunction}.
The same should also apply to {\metaobject Constructor}s and {\metaobject Operator}s.

The idea is that (direct) scope members (i.e. metaobjects accessible through \verb@Scope::member(...)@)
should have unique names.

The {\metaobject Scope} returned by the \verb@scope@ member function of every single
{\metaobject Function} in a {\metaobject OverloadedFunction}
is the same as the \verb@scope@ of that {\metaobject OverloadedFunction}, i.e.
the \verb@scope@ of a {\metaobject Function} can be a {\metaobject Namespace} or a {\metaobject Class}
but {\em not} a {\metaobject OverloadedFunction}.

\subsubsection{ClassMember}

{\metaobject ClassMember} is a {\metaobject Named} and {\metaobject Scoped} metaobject
that reflects a member of a class. It has the following requirements:

\begin{itemize}
	\item{\verb@static @{\metaobject Specifier}\verb@ access_type(void);@} static member function returning
	a {\metaobject Specifier} reflecting the access type specifier of the class member
	(\verb@private@, \verb@protected@ or \verb@public@).

	\item \verb@metaobject_traits<ClassMember::scope>::is_class_member@ is \verb@true_type@.
\end{itemize}

Concrete metaobjects that are models of this concept can also be some of the following:
\begin{itemize}
	\item{\metaobject Typedef}
	\item{\metaobject Class}
	\item{\metaobject Enum}
	\item{\metaobject OverloadedFunction}
\end{itemize}

\subsubsection{Constructor}

{\metaobject Constructor} is a {\metaobject ClassMember} and a {\metaobject Function} that
reflects a constructor and requires the following:

\begin{itemize}
	\item \verb@metaobject_traits<Constructor>::category@ is defined as  \verb@constructor_tag@.

	\item The result of \verb@Constructor::result_type()@ is the same as the result of
	\verb@Constructor::scope()@.
\end{itemize}

\subsubsection{Operator}

{\metaobject Operator} is a {\metaobject Function} and possibly a {\metaobject ClassMember}
that reflects an operator and requires the following:

\begin{itemize}
	\item \verb@metaobject_traits<Operator>::category@ is defined as  \verb@operator_tag@.
\end{itemize}

\subsubsection{OverloadedFunction}

{\metaobject OverloadedFunction} is a {\metaobject Named} and {\metaobject Scoped} metaobject
and possibly a {\metaobject ClassMember}
that reflects a set of overloaded functions, i.e. functions with the same name.
{\metaobject OverloadedFunction} has the following requirements:

\begin{itemize}

	\item{\verb@static integral_constant<int,@ {\em number-of-overloads}
	\verb@>@\\\verb@overload_count(void);@} static member function returning the total number
	of overloads of the function reflected by {\metaobject OverloadedFunction}.

	\item{\verb@static @{\metaobject Function}\verb@ overload(integral_constant<int, @{\em i}
	\verb@>);@} overloaded member function defined
	for $i \in \{0, 1, \dots, n-1\}$; {\em n = number-of-overloads},
	each overload returns a different {\metaobject Function} metaobject reflecting the {\em i}-th overload
	in the set of functions reflected by {\metaobject OverloadedFunction}.

	\item \verb@metaobject_traits<OverloadedFunction>::category@ is defined as 
	\verb@overloaded_function_tag@.
\end{itemize}

\subsubsection{Template}

{\metaobject Template} is a {\metaobject Function} or a {\metaobject Class} metaobject
that reflects a function or class template. It has the following requirements:

\begin{itemize}

	\item{\verb@static integral_constant<int,@ {\em number-of-template-parameters}
	\verb@>@\\\verb@template_parameter_count(void);@} static member function returning the total number
	of parameters of the template reflected by {\metaobject Template}.

	\item{\verb@static @{\metaobject TemplateParameter}\\\verb@template_parameter(integral_constant<int, @{\em i}
	\verb@>);@} overloaded member function defined
	for $i \in \{0, 1, \dots, n-1\}$; {\em n = number-of-parameters},
	each overload returns a different {\metaobject Parameter} metaobject reflecting the {\em i}-th parameter
	of the template reflected by {\metaobject Template}.

	\item{\verb@template <@ {\em template-parameters...} \verb@>@\\
	\verb@static Instantiation instantiation(void);@} static member template function returning an {\metaobject Instantiation}
	reflecting the instantiation of the template with the specified parameters. The {\em template-parameters} passed
	to this function must be valid template parameters for the reflected template.

	\item \verb@metaobject_traits<Template>::is_template@ is defined as \verb@true_type@.
\end{itemize}

\subsubsection{TemplateParameter}

{\metaobject TemplateParameter} is a {\metaobject Typedef} or a {\metaobject NamedConstant} that
reflects a template parameter. In class templates the types of member variables, typedefs and
the return value type and parameters of member functions may be {\metaobject TemplateParameter}
metaobjects.

\begin{itemize}
	\item{\verb@static integral_constant<int, @{\metaobject position-of-parameter}\verb@> postion(void);@}
	static member function returning the postion of the template parameter.

	\item The \verb@scope@ member function inherited from {\metaobject Scoped} returns a {\metaobject Template}
	reflecting the template which defined this template parameter.

	\item \verb@metaobject_traits<TemplateParameter>::is_template@ is defined as \verb@true_type@.
\end{itemize}

The \verb@metaobject_traits<TemplateParameter>::category@ typedef should be used to distinguish between
type and non-type template parameters.

\subsubsection{Instantiation}

{\metaobject Instantiation} is a {\metaobject Function} or {\metaobject Class} metaobject
that reflects a templated function or class for which the following is required:

\begin{itemize}

	\item{\verb@static @ {\metaobject Template} \verb@model(void);@} static member function returning
	a {\metaobject Template} reflecting the template that the class or function 
	(reflected by an {\metaobject Instantiation}) is an instantiation of.

	\item \verb@metaobject_traits<Instantiation>::has_template@ is defined as \verb@true_type@.
	This trait is used to distinguish classes and functions which are instantiations
	of a template from non-templated classes and functions.
\end{itemize}

\subsubsection{Enum}

{\metaobject Enum} is a {\metaobject Type} and a {\metaobject Scope} that reflects an enumerated
type with the following requirements:

\begin{itemize}
	\item \verb@metaobject_traits<Enum>::category@ is defined as \verb@enum_tag@.

	\item The \verb@members@ of {\metaobject Enum} are only {\metaobject NamedConstant} metaobjects.
\end{itemize}

\subsubsection{Inheritance}

{\metaobject Inheritance} is a {\metaobject Metaobject} that is reflecting class inheritance and has
the following requirements:

\begin{itemize}
	\item{\verb@static @{\metaobject Specifier}\verb@access_type(void);@} static member function
	returning a access-type {\metaobject Specifier} that reflects the inheritance access type
	(private, protected or public).

	\item{\verb@static @{\metaobject Specifier}\verb@inheritance_type(void);@} static member function
	returning an inheritance-type {\metaobject Specifier} that reflects the inheritance access type
	(virtual or non-virtual).

	\item{\verb@static @{\metaobject Class} \verb@ base_class(void);@} static member function
	returning a {\metaobject Class} reflecting the base class in the inheritance.

	\item{\verb@static @{\metaobject Class} \verb@ derived_class(void);@} static member function
	returning a {\metaobject Class} reflecting the derived class in the inheritance.

	\item \verb@metaobject_traits<Inheritance>::category@ is defined as \verb@inheritance_tag@.
\end{itemize}

\subsubsection{Variable}

{\metaobject Variable} is a {\metaobject Named} and {\metaobject Scoped} metaobject and possibly a
{\metaobject ClassMember}, that reflects some kind of variable defined in a namespace, class, function, etc.
and has the following requirements:

\begin{itemize}
	\item{\verb@static @{\metaobject Specifier}\verb@ storage_class();@} static member function returning
	a storage-class {\metaobject Specifier} reflecting the storage class of the variable.

	\item{\verb@static @{\metaobject Type}\verb@ type();@} static member function returning
	a {\metaobject Type} reflecting the type of the variable.

	\item \verb@metaobject_traits<Variable>::category@ is defined as \verb@variable_tag@.
\end{itemize}

\subsubsection{Parameter}

{\metaobject Parameter} is a {\metaobject Variable} that reflects a parameter of a function.
The following is required for metaobjects reflecting parameters:

\begin{itemize}
	\item{\verb@static integral_constant<int, @{\em position-of-parameter}\verb@> position(void);@}
	static member function returning the position of the parameter in the function parameter list
	declaration.

	\item \verb@metaobject_traits<Parameter>::category@ is defined as \verb@parameter_tag@.

	\item The \verb@scope@ member function inherited from {\metaobject Scoped} returns
	the {\metaobject Function} that the parameter belongs to.
\end{itemize}

\subsubsection{NamedConstant}

{\metaobject NamedConstant} is a {\metaobject Named} and possibly {\metaobject Scoped} metaobject reflecting
named compile-time constant values like the non-type template parameters and enumeration values.

\begin{itemize}
	\item{\verb@static integral_type<@{\em value-type}\verb@, @{\em constant-value}\verb@> value(void);@}
	static member function returning the reflected value wrapped in \verb@integral_constant@.

	\item \verb@metaobject_traits<NamedConstant>::category@ is defined as \verb@constant_tag@.
\end{itemize}

