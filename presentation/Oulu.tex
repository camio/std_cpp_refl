\documentclass[compress,table,xcolor=table]{beamer}
\mode<presentation>
\usetheme{Warsaw}
\hypersetup{pdfstartview={Fit}}

\usecolortheme{crane}
\useoutertheme{smoothbars}

\setbeamertemplate{bibliography item}[text]
\logo{%
  \usebeamerfont{footline}%
  \usebeamercolor[fg]{footline}%
  \hspace{1em}%
  \small{\insertframenumber/}\scriptsize{\inserttotalframenumber}
}

\definecolor{alert-color}{rgb}{0.40, 0.15, 0.50}
\setbeamercolor{alerted text}{fg=alert-color}

\usepackage[utf8]{inputenc}
\usepackage{caption}
\usepackage{enumitem}
\usepackage{dirtytalk}
\usepackage{multirow}

\definecolor{listing-bgcolor}{rgb}{0.85, 0.85, 1.00}

\usepackage{listings}
\lstset{
  backgroundcolor = \color{listing-bgcolor},
  basicstyle=\scriptsize\ttfamily,
  language=C++,
  breaklines=true,
  tabsize=2,
  escapeinside={(*@}{@*)}
}

\usepackage{url}

\setlist[itemize,1]{label=$\circ$,leftmargin=1em}
\setlist[itemize,2]{label=$\bullet$,leftmargin=1em}
\setlist[itemize,3]{label=$\diamond$,leftmargin=1em}

\author[Chochl\'{i}k M. -- Naumann A.]{Mat\'{u}\v{s} Chochl\'{i}k \and Axel Naumann}

\begin{document}

\title{P0194R1 -- Static reflection}

\section{Intro}

\begin{frame}
\begin{center}
  \Huge
  \textbf{P0194} -- {\em Static reflection}\\
  \normalsize
  \vspace{3em}
  Mat\'{u}\v{s} Chochl\'{i}k\\
  Axel Naumann
\end{center}
\end{frame}

\subsection{Proposal}

\begin{frame}[fragile]
\frametitle{{\em Call for Compile-Time Reflection Proposals} -- \textbf{N3814}}
  \large
  \begin{itemize}
    \item Targeted use cases:
    \begin{itemize}
      \item \textbf{Generation of common functions}
      \begin{itemize}
        \scriptsize
        \item comparison operators,
        \item serialization functions,
        \item hash functions,
        \item \ldots
      \end{itemize}
      \item \textbf{Type transformations}
      \begin{itemize}
        \scriptsize
        \item {\em struct-of-arrays},
        \item object-relational mapping,
        \item \ldots
      \end{itemize}
      \item \textbf{Compile-time context information}
      \begin{itemize}
        \scriptsize
        \item replacement for \verb@__FILE__@, \verb@__LINE__@, \ldots
      \end{itemize}
      \item \textbf{Enumeration of other entities}
      \begin{itemize}
        \scriptsize
        \item types in a namespace
        \item parameters of a function
        \item global variables in a namespace
        \item enumerators in an enumeration
        \item \ldots
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{Static reflection proposal}
  \begin{itemize}
    \large
    \item \textbf{Current iteration}
    \begin{itemize}
      \item \textbf{P0194R1} -- {\em Static reflection (rev.5)} {\small -- wording}
      \item \textbf{P0385R0} -- {\em Static reflection: {\small Rationale, design and evolution}}
    \end{itemize}
    \normalsize
    \item Previous revisions\footnote{see the revision history in P0194R1}
    \begin{itemize}
      \small
      \item \textbf{P0194R0} -- {\em Static reflection (rev.4)}
      \item \textbf{N4451} -- {\em Static reflection (rev.3)}
      \item \textbf{N4452} -- {\em A case for strong static reflection}
      \item \textbf{N4111} -- {\em Static reflection (rev.2)}
      \item \textbf{P3996} -- {\em Static reflection (rev.1)}
    \end{itemize}
  \end{itemize}
\end{frame}

\section{Overview}

\subsection{Metaobjects}
\begin{frame}
\frametitle{{\em Metaobject} -- abstract definition}
  \large
  \begin{itemize}
    \item \textbf{{\em A representation of a base-level program declaration.}}
    \item \textbf{Gives a first-class identity to the reflected entity.}
    \begin{itemize}
      \small
      \item Can be stored in a \say{variable}.
      \item Can be passed as an argument or a return value in a metaprogram.
      \item Separates the reflection of a declaration from
      the querying of the metadata.
    \end{itemize}
    \item \textbf{Can be reasoned-about at compile-time.}
    \item In some cases allows to \say{go back} to the reflected declaration.
    \item Conforms to one of the {\em metaobject concepts}.
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{{\em Metaobjects} -- implementation}
  \large
  \begin{itemize}
    \item \textbf{As anonymous implementation-defined types.}
    \begin{itemize}
      \small
      \item have first-class identity at compile-time
      \item lightweight
      \item no visible internal structure
      \item creation of run-time objects of these types is not required
      \item can be implemented as template-wrapped constants 
      \begin{lstlisting}
	template <__metaobject_id MoId> struct __metaobject;
      \end{lstlisting}
    \end{itemize}
    \item Returned by the \textbf{reflexpr} operator.
    \begin{lstlisting}[basicstyle=\normalsize\ttfamily]
	using meta_global_scope = (*@\alert{reflexpr}@*)(::);
	using meta_std = (*@\alert{reflexpr}@*)(std);
	using meta_int = (*@\alert{reflexpr}@*)(int);
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{Metaobject kinds}
    \large
    \begin{columns}[T]
      \begin{column}{0.50\textwidth}
      \begin{itemize}
        \item \textbf{In the current proposal}
        \begin{itemize}
          \normalsize
          \item the global scope,
          \item a namespace,
          \item a type,
          \item a class,
          \item a class data member,
          \item an enumeration,
          \item an enumeration value,
          \item a namespace or type alias,
          \item a specifier.
        \end{itemize}
      \end{itemize}
      \end{column}
      \begin{column}{0.45\textwidth}
      \begin{itemize}
        \item Future extensions\footnotemark
        \begin{itemize}
          \normalsize
          \item a template,
          \item a variable
          \item a function,
          \item a constructor,
          \item an operator,
          \item a template parameter,
          \item a function parameter,
          \item \ldots
        \end{itemize}
      \end{itemize}
      \end{column}
    \end{columns}
    \footnotetext{using same principles}
\end{frame}

\subsection{Metaobject operations}
\begin{frame}[fragile]
\frametitle{{\em Metaobject operations}}
  \large
  \begin{itemize}
    \item \textbf{Compile-time operations adding functionality to the {\em metaobjects}.}
    \item One or several of their arguments are {\em metaobjects}.
    \item Return compile-time metadata or other metaobjects.
    \item \textbf{Implemented as class templates:}
    \begin{lstlisting}[basicstyle=\normalsize\ttfamily]
	using meta_str = reflexpr(std::string);
	(*@\alert{get\_name\_v}@*)<meta_str>;          // "string"
	using meta_std = (*@\alert{get\_scope\_m}@*)<meta_str>;
	(*@\alert{get\_name\_v}@*)<meta_std>;          // "std"
	(*@\alert{reflected\_type\_t}@*)<meta_str> str("blah");
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}
\frametitle{{\em Metaobject operations} -- \say{return values}}
  \large
  \begin{itemize}
    \item \textbf{Compile-time metadata} in the form of:
    \begin{itemize}
      \normalsize
      \item boolean constants,
      \item integral constants,
      \item enumerator constants,
      \item string constants,
      \item other (data member pointers, \ldots)
    \end{itemize}
    \item \textbf{Metaobjects} reflecting:
    \begin{itemize}
      \normalsize
      \item scope,
      \item class data members, class member typedefs, class inheritance,
      \item parameters, the return value,
      \item aliased declarations,
      \item various specifiers,
      \item \ldots
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Metaobject concepts}
\begin{frame}
\frametitle{{\em Metaobject concepts}}
  \begin{itemize}
    \item Determine the \textbf{category} of a metaobject -- \textbf{what does it reflect}.
    \item \large \textbf{Determine which operations can be invoked on a metaobject.}
  \end{itemize}
  \begin{columns}
    \scriptsize
    \begin{column}{0.35\textwidth}
      \begin{itemize}
      \setlength\itemsep{0.1em}
      \item \texttt{Object}
      \item \texttt{ObjectSequence}
      \item \texttt{Reversible}
      \item \texttt{Named}
      \item \texttt{Typed}
      \item \texttt{ScopeMember}
      \item \texttt{Scope}
      \item \texttt{Alias}
      \item \texttt{ClassMember}
      \item \texttt{Linkable}
      \item \texttt{Constant}
      \item \texttt{Specifier}
      \end{itemize}
    \end{column}
    \begin{column}{0.35\textwidth}
      \begin{itemize}
      \setlength\itemsep{0.1em}
      \item \texttt{Namespace}
      \item \texttt{GlobalScope}
      \item \texttt{NamespaceAlias}
      \item \texttt{Type}
      \item \texttt{TypeAlias}
      \item \texttt{Class}
      \item \texttt{Enum}
      \item \texttt{EnumClass}
      \item \texttt{Variable}
      \item \texttt{DataMember}
      \item \texttt{MemberType}
      \item \texttt{EnumValue}
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{{\em Metaobject concepts}}
  \begin{itemize}
    \item \textbf{Distinguishing metaobjects} from other types -- \textbf{the
    \texttt{is\_metaobject} type trait}:
    \begin{lstlisting}
	template <typename T> is_metaobject 
	 : integral_constant<bool, (*@{\em implementation-defined}@*)> { };

	template <typename T> constexpr bool is_metaobject_v
	 = is_metaobject<T>::value;
    \end{lstlisting}
    \item \textbf{The \texttt{meta::Object} concept:}
    \begin{lstlisting}
	template <typename T> concept bool Object
	 = is_metaobject_v<T>;
    \end{lstlisting}
    \item All other \textbf{metaobjects form a} generalization-specialization
      \textbf{hierarchy} and have additional requirements:
    \begin{lstlisting}
	template <typename T> concept bool Named
	 = Object<T> && (*@{\em implementation-defined}@*);
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{{\em Metaobject sequences}}
  \begin{itemize}
    \item Lightweight \say{handle} to an ordered sequence of metaobjects.
    \begin{itemize}
      \footnotesize
      \item class or namespace members,
      \item list of storage class specifiers,
      \item list of base class inheritance specifiers,
      \item \ldots
    \end{itemize}
    \item \textbf{Does not instantiate \say{contained} metaobjects eagerly.}
    \item Definition:
    \begin{lstlisting}
	template <typename T> concept bool ObjectSequence
	 = Object<T> && (*@{\em implementation-defined}@*);
    \end{lstlisting}
    \item \textbf{Operations:}
    \begin{lstlisting}
	template <ObjectSequence S>           struct get_size;
	template <ObjectSequence S, size_t I> struct get_element;

	template <ObjectSequence S, template <class...> class Tpl>
	struct unpack_sequence;
    \end{lstlisting}
  \end{itemize}
\end{frame}

\section{Interface}

\subsection{Header}
\begin{frame}[fragile]
\frametitle{\em The \texttt{<reflexpr>} header file}
  \begin{itemize}
    \item \textbf{Must be included} prior to the use of \texttt{reflexpr}.
    \item Defines the metaobject concepts.
    \item Implements the metaobject operations.
    \item All \textbf{reflection-related declarations go to} the \textbf{namespace
    \texttt{std::meta}}, \textbf{except for} the \textbf{\texttt{is\_metaobject} trait}:
    \begin{lstlisting}
	namespace std {
	  template <typename T> is_metaobject;

	  namespace meta {
	    template <typename T> concept bool Object;
	    template <Object T> concept bool Named;
	    ...
	    template <Named MO> struct get_name;
	    ...
	  } // namespace meta
	} // namespace std
    \end{lstlisting}
  \end{itemize}
\end{frame}

\subsection{Why TMP interface?}
\begin{frame}[fragile]
\frametitle{Why a template metaprogramming interface?}
  \large
  \begin{itemize}
    \item \textbf{Tried paradigm} with approximately 15 years of experience.
    \item The pros and cons are generally known.
    \item Lots of \textbf{existing TMP libraries} and utilities.
    \item \textbf{Consistent with} the existing \textbf{type-traits} and other
      standard and third-party metaprogramming utilities.
    \item \textbf{Other interfaces}, both compile-time and run-time \textbf{can}
      and will \textbf{be implemented on top of the TMP interface}.
    \begin{lstlisting}
	template <Object MO> struct metaobject;

	template <Object MO>
	constexpr auto get_name(metaobject<MO>) {
	    return meta::get_name_v<MO>;
	}
    \end{lstlisting}
  \end{itemize}
\end{frame}

\section{Notable features}

\subsection{Typedef reflection}
\begin{frame}[fragile]
\frametitle{Typedef reflection -- unnamed \texttt{struct}}
  \small
  \begin{itemize}
    \item Suppose that we have the following \verb@typedef@ to an unnamed
      \verb@struct@\footnote{possibly in third-party code}:
    \begin{lstlisting}{cpp}[basicstyle=\small\ttfamily]
	typedef struct { int a, b, c; } my_struct;
    \end{lstlisting}
    \item \textbf{We want to serialize instances} of this \verb@struct@
      for network transport, \textbf{including the type name} in the data format:
      \begin{lstlisting}{cpp}{
	cout << "{" << '"' << "type" << '"' << ": " << '"'
	     << get_name_v<reflexpr(my_struct)>
	     << '"' << ", " << '"' << "attr" << '"' << ": {";
	/* ... */
	cout << "}}";
      \end{lstlisting}
    \item Output \textbf{without \texttt{typedef}} reflection:
    \begin{lstlisting}[basicstyle=\small\ttfamily]
	{"type":        (*@\alert{""}@*), "attr": { ... }}
    \end{lstlisting}
    \item Output \textbf{with \texttt{typedef}} reflection:
    \begin{lstlisting}[basicstyle=\small\ttfamily]
	{"type": (*@\alert{"my\_struct"}@*), "attr": { ... }}
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Typedef reflection -- inter-platform differences}
  \small
  \begin{itemize}
    \item Let's suppose that we have the following declarations:
    \begin{lstlisting}{cpp}
	#if PLATFORM_X
	  typedef int       int32_t;
	  typedef (*@\alert{long}@*)       int64_t;
	#elif PLATFORM_Y
	  typedef long      int32_t;
	  typedef (*@\alert{long long}@*)   int64_t;
	#endif
	struct abc { (*@\alert{int64\_t}@*) a, b, c; };
    \end{lstlisting}
    \item We serialize instances of this \verb@struct@ \textbf{on platform X} and
      send them over the network to platform Y:
    \item \textbf{Without \texttt{typedef}} reflection:
    \begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
	"attr":{"a":{"t":"(*@\alert{long}@*)", "v":"(*@\alert{92233720368547758}@*)"},...}
    \end{lstlisting}
    \item \textbf{With \texttt{typedef}} reflection:
    \begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
	"attr":{"a":{"t":"(*@\alert{int64\_t}@*)","v":"(*@\alert{92233720368547758}@*)"},...}
    \end{lstlisting}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Typedef reflection -- inter-platform differences (cont.)}
  \small
  \begin{itemize}
  \item \ldots meanwhile at the receiving end \textbf{on platform Y}:
    \begin{itemize}
    \item \textbf{Without \texttt{typedef}} reflection
      \begin{lstlisting}{cpp}
	json_obj obj = json_obj::from_string(json_str);
	auto attr = obj["attr"]["a"];
	/* ... */
	if(attr["t"] == "long") {
	   (*@\alert{long}@*) tmp;
	   attr["v"] >> tmp; // (*@\alert{32-bit int overflow?, exception?}@*)
	} /* ... */
      \end{lstlisting}
    \item \textbf{With \texttt{typedef}} reflection
      \begin{lstlisting}{cpp}
	json_obj obj = json_obj::from_string(json_str);
	auto attr = obj["attr"]["a"];
	/* ... */
	if(attr["t"] == "int64_t") {
	   (*@\alert{int64\_t}@*) tmp;
	   attr["v"] >> tmp; // (*@\alert{A-OK}@*)
	} /* ... */
      \end{lstlisting}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{Typedef reflection -- Diagnostics and logging}
  \begin{itemize}
  \item We want to log function calls -- why not \textbf{use reflection to get
    type names}, source location info, etc.
  \item Output \textbf{without \texttt{typedef}} reflection:
    \begin{itemize}
      \footnotesize
      \item Depends on the platform, compiler and the implementation of
        the standard library.
      \item May depend on build configuration (debug/release, 32-bit/64-bit)
    \end{itemize}
  \item Output \textbf{with \texttt{typedef}} reflection:
    \begin{itemize}
      \small
      \item Same on every platform
      \item Same for every build configuration
      \item Preserves semantic meaning
      \item Matches the names in output to what is used in the code.
    \end{itemize}
  \end{itemize}
  \large
  If compiler error diagnostic output is aware of typedef names,
    \textbf{why shouldn't reflection do the same?}
\end{frame}

\subsection{Non-public member reflection}
\begin{frame}[fragile]
\frametitle{Non-public member reflection}
  \begin{itemize}
    \item \textbf{Necessary for several use cases} (serialization, etc.)
    \item Guidance from JAX: {\em Non-public reflection yes, but {\em greppable}.}
    \item \textbf{Variants of operations} for {\em obtaining} the reflections
      of the non-public members:
    \begin{itemize}
      \footnotesize
      \item \texttt{get\_data\_members} vs. \texttt{\alert{get\_all\_data\_members}}
      \item \texttt{get\_member\_types} vs. \texttt{\alert{get\_all\_member\_types}}
      \item \ldots
    \end{itemize}
    \item Variants of operations for {\em going back} to the base-level?
    \begin{itemize}
      \footnotesize
      \item \texttt{get\_pointer} vs. \texttt{\alert{get\_nonpublic\_pointer}}
      \item \texttt{get\_reflected\_type} vs. \texttt{\alert{get\_nonpublic\_reflected\_type}}
      \item {\em greppable}, but does not scale very well
    \end{itemize}
    \item Freely access metadata; name, type information, scope information, etc.
  \end{itemize}
\end{frame}

\end{document}
