\documentclass[compress,table,xcolor=table]{beamer}
\mode<presentation>
\usetheme{Warsaw}
\hypersetup{pdfstartview={Fit}}

\usecolortheme{crane}
\useoutertheme{smoothbars}

\setbeamertemplate{bibliography item}[text]
\usepackage[utf8]{inputenc}
\usepackage{caption}
\usepackage{enumitem}
\usepackage{dirtytalk}
\usepackage{multirow}

\usepackage{listings}
\lstset{
basicstyle=\scriptsize\ttfamily,
language=C++,
breaklines=true,
tabsize=2,
escapeinside={(*@}{@*)}
}

\usepackage{url}

\setlist[itemize,1]{label=$\circ$,leftmargin=1em}
\setlist[itemize,2]{label=$\bullet$,leftmargin=1em}
\setlist[itemize,3]{label=$\diamond$,leftmargin=1em}

\author[Chochl\'{i}k M. -- Naumann A.]{Mat\'{u}\v{s} Chochl\'{i}k \and Axel Naumann}

\begin{document}

\title{Static reflection}

\section{Overview}

\subsection{Metaobject}
\begin{frame}
\frametitle{{\em Metaobject}}
  \begin{itemize}
    \small
    \item A representation of a base-level program declaration\footnote
      {only some of these are part of the initial proposal}:
    \begin{itemize}
      \scriptsize
      \item the global scope, a namespace,
      \item a type, a class, an enumeration,
      \item a namespace or type alias,
      \item a template,
      \item a variable, a class data member,
      \item a function, a constructor, an operator,
      \item a template parameter, a function parameter,
      \item \ldots
    \end{itemize}
    \item Gives a first-class identity to the reflected entity
    \begin{itemize}
      \scriptsize
      \item Can be stored in a \say{variable}.
      \item Can be passed as an argument or a return value around a metaprogram.
      \item Allows to separate the reflection of a declaration from
      the querying of the metadata.
    \end{itemize}
    \item Can be reasoned-about at compile-time.
    \item Metaobjects conform to various {\em concepts}.
  \end{itemize}
\end{frame}

\subsection{Metaobject operations}
\begin{frame}
\frametitle{{\em Metaobject operations}}
  \begin{itemize}
    \small
    \item Compile-time operations adding functionality to the {\em metaobjects}.
    \item One or several of their arguments are {\em metaobjects}.
    \item The return value can be one of the following:
    \begin{itemize}
      \footnotesize
      \item Metadata in the form of:
      \begin{itemize}
        \item boolean constants,
        \item integral constants,
        \item enumeration constants,
        \item string constants,
        \item other (class data member pointers, \ldots),
      \end{itemize}
      \item Metaobjects reflecting:
      \begin{itemize}
        \item scope,
        \item class data members, class member typedefs, class inheritance,
        \item parameters, the return value,
        \item aliased declarations,
        \item various specifiers,
        \item \ldots
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Metaobject concepts}
\begin{frame}
\frametitle{{\em Metaobject concepts}}
  \begin{itemize}
    \small
    \item Determine the category of a metaobject (what does it reflect).
    \item Determine which operations can be invoked on a metaobject.
  \end{itemize}
  \begin{columns}
    \scriptsize
    \begin{column}{0.35\textwidth}
      \begin{itemize}
      \item \texttt{Object}
      \item \texttt{ObjectSequence}
      \item \texttt{Reversible}
      \item \texttt{Named}
      \item \texttt{Typed}
      \item \texttt{ScopeMember}
      \item \texttt{Scope}
      \item \texttt{Alias}
      \item \texttt{ClassMember}
      \item \texttt{Linkable}
      \item \texttt{Constant}
      \item \texttt{Specifier}
      \end{itemize}
    \end{column}
    \begin{column}{0.35\textwidth}
      \begin{itemize}
      \item \texttt{Namespace}
      \item \texttt{GlobalScope}
      \item \texttt{NamespaceAlias}
      \item \texttt{Type}
      \item \texttt{TypeAlias}
      \item \texttt{Class}
      \item \texttt{Enum}
      \item \texttt{EnumClass}
      \item \texttt{Variable}
      \item \texttt{DataMember}
      \item \texttt{MemberType}
      \item \texttt{EnumValue}
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\section{Interface}

\subsection{Template metaprogramming}
\begin{frame}[fragile]
\frametitle{Template metaprogramming}
  \small
  \begin{itemize}
    \item Tried paradigm with approx. 15 years of experience.
    \item The pros and cons are generally known.
    \item Lots of existing TMP libraries and utilities.
    \item How does the above translate into valid C++?
    \begin{itemize}
      \footnotesize
      \item {\em Metaobjects} -- anonymous types generated by the compiler on-demand
      when the \texttt{\textbf{reflexpr}} operator is invoked --
      \textbf{Cannot be instantiated}.
      \item {\em Metaobject concepts} -- C++ Concepts
      \item {\em Metaobject operations} -- class templates
    \end{itemize}
    \item Consistent with the existing type-traits and other standard and
      third-party metaprogramming utilities.
    \item Allows to implement the metaobjects as constants wrapped into a
    lightweight class template:
    \begin{lstlisting}{cpp}
	template <__metaobject_id MoId> struct __metaobject;
    \end{lstlisting}
  \end{itemize}
\end{frame}

\subsection{Other paradigms}
\begin{frame}[fragile]
\frametitle{Other paradigms}
  \begin{itemize}
    \item C++11/14 brought support for new compile-time metaprogramming paradigms.
    \begin{itemize}
      \small
      \item Constexpr metaprogramming -- Boost.Hana \& co.
      \item The metaobject types can be wrapped into a named template which
        can be used as the parameter for \texttt{constexpr} functions:
      \begin{lstlisting}{cpp}
	template <meta::Object M> struct metaobject { };

	template <meta::Named M>
	constexpr const char* get_name(metaobject<M>);
      \end{lstlisting}
      \item Or a constant metaobject id can be directly exposed later:
      \begin{lstlisting}{cpp}
	template <metaobject_id MoId> struct metaobject { };

	template <metaobject_id M>
	constexpr const char* get_name(metaobject<M>);
      \end{lstlisting}
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Other paradigms}
\begin{frame}[fragile]
\frametitle{Other paradigms}
  \begin{itemize}
    \item The Mirror reflection utilities\footnote
      {\tiny{\url{http://kifri.fri.uniza.sk/~chochlik/mirror-lib/html/}}}
      show that it is possible to implement other interfaces on top of the TMP layer.
      \begin{itemize}
        \small
        \item Compile-time OOP-like layer
        \begin{lstlisting}{cpp}
	auto meta_person = reflected_type<sample::person>();
	assert(meta_person.is_class());
	assert(meta_person.get_name() == "person");
	assert(meta_person.scope().is_namespace());
	assert(meta_person.scope().get_name() == "sample");
        \end{lstlisting}
	\item A type erasure (not using virtual functions)
	\item Polymorphic reflection layer (using virtual functions)
        \begin{lstlisting}{cpp}
	for_each(
	    reflected_global_scope()->members(),
	    [](const shared<meta_named>& mo)
	    {
	        std::cout << mo->get_name() << std::endl;
	    }
	);
        \end{lstlisting}
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Notable features}

\subsection{Typedef reflection}
\begin{frame}[fragile]
\frametitle{Typedef reflection}
  \small
  \begin{itemize}
    \item Why do we need typedef reflection\footnote{and alias reflection
      in general}?
    \begin{itemize}
      \footnotesize
      \item {\em Typedefs to unnamed \verb@struct@s} -- we need to recognize
      and refer to them somehow.
      \item Semantic meaning -- important in many use cases. For example
        \verb@int_64@ means \say{64-bit} while \verb@long@ does not generally
	express this.
      \item {\em Platform independence}
        \begin{itemize}
          \item Commonly used types like \verb@size_t@, \verb@string::iterator@
          and many more are defined differently on different platforms.
          \item Without typedef reflection cross-platform name
          lookups can get difficult.
        \end{itemize}
      \item {\em Diagnostics and logging} -- many compilers already use typedef
        names in diagnostic messages for good reasons. Reflection-based logging
        facilities may want to do the same.
    \end{itemize}
    \item Typedef reflection is an optional feature, it is always possible to get
      to the underlying type, the inverse is not true.

  \end{itemize}
\end{frame}

\subsection{Non-public member reflection}
\begin{frame}[fragile]
\frametitle{Non-public member reflection}
  \small
  \begin{itemize}
    \item Necessary for several use cases (serialization, etc.)
    \item Obtaining metaobjects reflecting non-public class members:
    \begin{itemize}
      \footnotesize
      \item \verb@get_data_members@ vs. \verb@get_all_data_members@
      \item \verb@get_member_types@ vs. \verb@get_all_member_types@
      \item \ldots
    \end{itemize}
    \item Freely access metadata; name, type information, scope information, etc.
    \item Explicitly request access\footnote{and make that easily
      \texttt{grep}pable in the code} when {\em manipulating} the base-level:
    \begin{itemize}
      \footnotesize
        \item Special variant of the operations:
        \begin{itemize}
          \scriptsize
          \item \verb@get_pointer@ vs. \verb@get_private_pointer@
          \item \verb@get_reflected_type@ vs. \verb@get_private_reflected_type@
          \item does not scale very well
        \end{itemize}
        \item Use reverse reflection\footnote{more on that in a second} instead:
        \begin{lstlisting}{cpp}
	reflexpr((*@\alert{private,}@*) meta_MyClass_private_member);
        \end{lstlisting}
    \end{itemize}
  \end{itemize}
\end{frame}

\section{Future extensions}

\subsection{Additional concepts}
\begin{frame}
\frametitle{Additional concepts and operations}
  \begin{itemize}
    \small
    \item Concepts for metaobjects reflecting language features not covered
    by the initial proposal.
  \end{itemize}
  \begin{columns}
    \scriptsize
    \begin{column}{0.35\textwidth}
      \begin{itemize}
      \item \texttt{OverloadedFunction}
      \item \texttt{Function}
      \item \texttt{Constructor}
      \item \texttt{Operator}
      \item \texttt{FunctionParameter}
      \item \texttt{Annotation}
      \end{itemize}
    \end{column}
    \begin{column}{0.40\textwidth}
      \begin{itemize}
      \item \texttt{Template}
      \item \texttt{TemplateParameter}
      \item \texttt{TemplateTypeParameter}
      \item \texttt{TemplateNonTypeParameter}
      \item \texttt{TemplateTemplateParameter}
      \item \ldots
      \end{itemize}
    \end{column}
  \end{columns}
  \begin{itemize}
    \small
    \item Additional operations working on these concepts.
  \end{itemize}
  \begin{columns}
    \scriptsize
    \begin{column}{0.45\textwidth}
      \begin{itemize}
      \item \texttt{get\_overloads}
      \item \texttt{get\_function\_parameters}
      \item \texttt{get\_result\_type}
      \item \texttt{get\_storage\_class\_specifiers}
      \end{itemize}
    \end{column}
    \begin{column}{0.40\textwidth}
      \begin{itemize}
      \item \texttt{get\_instantiation}
      \item \texttt{get\_template}
      \item \texttt{get\_template\_parameters}
      \item \ldots
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Reverse reflection}
\begin{frame}[fragile]
\frametitle{Reverse reflection}
  \small
  \begin{itemize}
    \item What happens when a metaobject is passed as the argument
      to \texttt{reflexpr}?
    \begin{itemize}
      \item If the metaobject is not a model of \texttt{Reversible} -- ill-formed.
      \item If the metaobject is a \texttt{Reversible} -- {\em reverse reflection}.
    \end{itemize}
    \item Reverse reflection -- as if the reflected declaration was used:
    \begin{itemize}
      \item Already in the proposal:
      \begin{lstlisting}{cpp}
	using meta_int = reflexpr(int);
	// same as: int i = 123;
	(*@\alert{reflexpr(meta\_int)}@*) i = 123;
      \end{lstlisting}
      \item In the future (among other things):
      \begin{lstlisting}{cpp}
	struct S { int i; };
	S s{123};
	// same as: s.i == 123
	assert(s.(*@\alert{reflexpr(reflexpr(S::i))}@*) == 123);
	// same as: std::string str;
	(*@\alert{reflexpr(reflexpr(std))}@*)::string str;
      \end{lstlisting}
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Identifier formatting}
\begin{frame}[fragile]
\frametitle{Identifier formatting}
  \small
  \begin{itemize}
    \item The ability to generate identifiers programmatically\footnote{without
       the preprocessor} is important for several use cases.
    \begin{itemize}
      \footnotesize
      \item Structure-of-arrays generators
      \item Object-relational mapping
      \item \ldots
    \end{itemize}
    \item Let's use special operator, say \verb@identifier@\footnote{let the
      bike-shedding begin}, with a format string literal
      and a set of \verb@meta::Named@ metaobjects:
      \begin{lstlisting}{cpp}
	struct bar { int foo; };
	using m_bar = reflexpr(bar);
	using m_foo = reflexpr(bar::foo);

	int (*@\alert{identifier("baz")}@*);               //int baz;
	int (*@\alert{identifier("\%1", m\_bar)}@*);          //int bar;
	int (*@\alert{identifier("\%2\_\%1", m\_bar, m\_foo)}@*);  //int foo_bar;
	int (*@\alert{identifier("my\_\%1\_\%2", m\_bar, m\_foo)}@*);//int my_bar_foo;
      \end{lstlisting}
  \end{itemize}
\end{frame}

\subsection{Variadic composition}
\begin{frame}[fragile]
\frametitle{Variadic composition}
  \scriptsize
  \begin{itemize}
    \item Allows more straightforward implementation of structure transformations:
    \begin{itemize}
      \item suppose we have a \verb@struct@ which we want to transform;
      \begin{lstlisting}{cpp}
	struct original { T1 attr1; T2 attr2; T3 attr3; };
      \end{lstlisting}
      \item with the following helper using identifier generation and variadic
        composition,
      \begin{lstlisting}{cpp}
	template <DataMember ... MDM> struct soa_helper {
	    std::vector<reflexpr(meta::get_type_t<MDM>)>
	        (*@\alert{identifier("vec\_\%1", MDM)...}@*);
	};
      \end{lstlisting}
      \item instantiating the \verb@soa_helper@:
      \begin{lstlisting}{cpp}
	using mdm = get_data_members_m<reflexpr(original)>;
	using soa_orig = expand_sequence_t<mdm, soa_helper>;
      \end{lstlisting}
      \item would result in the following structure:
      \begin{lstlisting}{cpp}
	struct {
	    std::vector<T1> vec_attr1;
	    std::vector<T2> vec_attr2;
	    std::vector<T3> vec_attr3;
	};
      \end{lstlisting}
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Context-dependent reflection}
\begin{frame}[fragile]
\frametitle{Context-dependent reflection}
  \small
  \begin{itemize}
    \item Would allow to obtain metadata based on the context in which the
      reflection operator is invoked, instead of on the declaration name:
    \begin{itemize}
      \footnotesize
      \item \verb@reflexpr(this::namespace)@ -- the innermost enclosing namespace.
      \item \verb@reflexpr(this::class)@ -- the innermost enclosing class.
      \item \verb@reflexpr(this::template)@ -- the innermost enclosing template.
      \item \verb@reflexpr(this::function)@ -- the enclosing function.
    \end{itemize}
    \item Helpful in several distinct use cases
    \begin{itemize}
      \footnotesize
        \item Implementation of logging
        \item Implementation of cross-cutting aspects
        \item \ldots
    \end{itemize}
  \end{itemize}
\end{frame}

\end{document}
