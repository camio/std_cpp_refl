\documentclass[compress,table,xcolor=table]{beamer}
\mode<presentation>
\usetheme{Warsaw}
\hypersetup{pdfstartview={Fit}}

\usecolortheme{crane}
\useoutertheme{smoothbars}

\setbeamertemplate{bibliography item}[text]
\usepackage[utf8]{inputenc}
\usepackage{caption}
\usepackage{enumitem}
\usepackage{dirtytalk}
\usepackage{multirow}

\definecolor{light-gray}{gray}{0.95}

\usepackage{listings}
\lstset{
backgroundcolor = \color{light-gray},
basicstyle=\scriptsize\ttfamily,
language=C++,
breaklines=true,
tabsize=2,
escapeinside={(*@}{@*)}
}

\usepackage{url}

\setlist[itemize,1]{label=$\circ$,leftmargin=1em}
\setlist[itemize,2]{label=$\bullet$,leftmargin=1em}
\setlist[itemize,3]{label=$\diamond$,leftmargin=1em}

\author[Chochl\'{i}k M. -- Naumann A.]{Mat\'{u}\v{s} Chochl\'{i}k \and Axel Naumann}

\begin{document}

\title{Static reflection}

\section{Overview}

\subsection{Metaobject}
\begin{frame}
\frametitle{{\em Metaobject}}
  \begin{itemize}
    \small
    \item A representation of a base-level program declaration\footnote
      {only some of these are part of the initial proposal}:
    \begin{itemize}
      \scriptsize
      \item the global scope, a namespace,
      \item a type, a class, an enumeration,
      \item a namespace or type alias,
      \item a template,
      \item a variable, a class data member,
      \item a function, a constructor, an operator,
      \item a template parameter, a function parameter,
      \item \ldots
    \end{itemize}
    \item Gives a first-class identity to the reflected entity
    \begin{itemize}
      \scriptsize
      \item Can be stored in a \say{variable}.
      \item Can be passed as an argument or a return value around a metaprogram.
      \item Allows to separate the reflection of a declaration from
      the querying of the metadata.
    \end{itemize}
    \item Can be reasoned-about at compile-time.
    \item Metaobjects conform to various {\em concepts}.
  \end{itemize}
\end{frame}

\subsection{Metaobject operations}
\begin{frame}
\frametitle{{\em Metaobject operations}}
  \begin{itemize}
    \small
    \item Compile-time operations adding functionality to the {\em metaobjects}.
    \item One or several of their arguments are {\em metaobjects}.
    \item The return value can be one of the following:
    \begin{itemize}
      \footnotesize
      \item Metadata in the form of:
      \begin{itemize}
        \item boolean constants,
        \item integral constants,
        \item enumeration constants,
        \item string constants,
        \item other (class data member pointers, \ldots),
      \end{itemize}
      \item Metaobjects reflecting:
      \begin{itemize}
        \item scope,
        \item class data members, class member typedefs, class inheritance,
        \item parameters, the return value,
        \item aliased declarations,
        \item various specifiers,
        \item \ldots
      \end{itemize}
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Metaobject concepts}
\begin{frame}
\frametitle{{\em Metaobject concepts}}
  \begin{itemize}
    \small
    \item Determine the category of a metaobject (what does it reflect).
    \item Determine which operations can be invoked on a metaobject.
  \end{itemize}
  \begin{columns}
    \scriptsize
    \begin{column}{0.35\textwidth}
      \begin{itemize}
      \item \texttt{Object}
      \item \texttt{ObjectSequence}
      \item \texttt{Reversible}
      \item \texttt{Named}
      \item \texttt{Typed}
      \item \texttt{ScopeMember}
      \item \texttt{Scope}
      \item \texttt{Alias}
      \item \texttt{ClassMember}
      \item \texttt{Linkable}
      \item \texttt{Constant}
      \item \texttt{Specifier}
      \end{itemize}
    \end{column}
    \begin{column}{0.35\textwidth}
      \begin{itemize}
      \item \texttt{Namespace}
      \item \texttt{GlobalScope}
      \item \texttt{NamespaceAlias}
      \item \texttt{Type}
      \item \texttt{TypeAlias}
      \item \texttt{Class}
      \item \texttt{Enum}
      \item \texttt{EnumClass}
      \item \texttt{Variable}
      \item \texttt{DataMember}
      \item \texttt{MemberType}
      \item \texttt{EnumValue}
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\section{Interface}

\subsection{Template metaprogramming}
\begin{frame}[fragile]
\frametitle{Template metaprogramming}
  \small
  \begin{itemize}
    \item Tried paradigm with approx. 15 years of experience.
    \item The pros and cons are generally known.
    \item Lots of existing TMP libraries and utilities.
    \item How does the above translate into valid C++?
    \begin{itemize}
      \footnotesize
      \item {\em Metaobjects} -- anonymous types generated by the compiler on-demand
      when the \texttt{\textbf{reflexpr}} operator is invoked --
      \textbf{Cannot be instantiated}.
      \item {\em Metaobject concepts} -- C++ Concepts
      \item {\em Metaobject operations} -- class templates
    \end{itemize}
    \item Consistent with the existing type-traits and other standard and
      third-party metaprogramming utilities.
    \item Allows to implement the metaobjects as constants wrapped into a
    lightweight class template:
    \begin{lstlisting}{cpp}
	template <__metaobject_id MoId> struct __metaobject;
    \end{lstlisting}
  \end{itemize}
\end{frame}

\subsection{Other paradigms}
\begin{frame}[fragile]
\frametitle{Other paradigms}
  \begin{itemize}
    \item C++11/14 brought support for new compile-time metaprogramming paradigms.
    \begin{itemize}
      \small
      \item Constexpr metaprogramming -- Boost.Hana \& co.
      \item The metaobject types can be wrapped into a named template which
        can be used as the parameter for \texttt{constexpr} functions:
      \begin{lstlisting}{cpp}
	template <meta::Object M> struct metaobject { };

	template <meta::Named M>
	constexpr const char* get_name(metaobject<M>);
      \end{lstlisting}
      \item Or a constant metaobject id can be directly exposed later:
      \begin{lstlisting}{cpp}
	template <metaobject_id MoId> struct metaobject { };

	template <metaobject_id M>
	constexpr const char* get_name(metaobject<M>);
      \end{lstlisting}
    \end{itemize}
  \end{itemize}
\end{frame}

\subsection{Other paradigms}
\begin{frame}[fragile]
\frametitle{Other paradigms}
  \begin{itemize}
    \item The Mirror reflection utilities\footnote
      {\tiny{\url{http://kifri.fri.uniza.sk/~chochlik/mirror-lib/html/}}}
      show that it is possible to implement other interfaces on top of the TMP layer.
      \begin{itemize}
        \small
        \item Compile-time OOP-like layer
        \begin{lstlisting}{cpp}
	auto meta_person = reflected_type<sample::person>();
	assert(meta_person.is_class());
	assert(meta_person.get_name() == "person");
	assert(meta_person.scope().is_namespace());
	assert(meta_person.scope().get_name() == "sample");
        \end{lstlisting}
	\item A type erasure (not using virtual functions)
	\item Polymorphic reflection layer (using virtual function)
        \begin{lstlisting}{cpp}
	for_each(
	    reflected_global_scope()->members(),
	    [](const shared<meta_named>& mo)
	    {
	        std::cout << mo->get_name() << std::endl;
	    }
	);
        \end{lstlisting}
      \end{itemize}
  \end{itemize}
\end{frame}

\section{Notable features}

\subsection{Typedef reflection}
\begin{frame}
\frametitle{Typedef reflection}
\Huge TODO
\end{frame}

\subsection{Non-public member reflection}
\begin{frame}
\frametitle{Non-public member reflection}
\Huge TODO
\end{frame}

\section{Future extensions}

\subsection{Additional concepts}
\begin{frame}
\frametitle{Additional concepts and operations}
  \begin{itemize}
    \small
    \item Concepts for metaobjects reflecting language features not covered
    by the initial proposal.
  \end{itemize}
  \begin{columns}
    \scriptsize
    \begin{column}{0.35\textwidth}
      \begin{itemize}
      \item \texttt{OverloadedFunction}
      \item \texttt{Function}
      \item \texttt{Constructor}
      \item \texttt{Operator}
      \item \texttt{FunctionParameter}
      \item \texttt{Annotation}
      \end{itemize}
    \end{column}
    \begin{column}{0.40\textwidth}
      \begin{itemize}
      \item \texttt{Template}
      \item \texttt{TemplateParameter}
      \item \texttt{TemplateTypeParameter}
      \item \texttt{TemplateNonTypeParameter}
      \item \texttt{TemplateTemplateParameter}
      \item \ldots
      \end{itemize}
    \end{column}
  \end{columns}
  \begin{itemize}
    \small
    \item Additional operations working on these concepts.
  \end{itemize}
  \begin{columns}
    \scriptsize
    \begin{column}{0.45\textwidth}
      \begin{itemize}
      \item \texttt{get\_overloads}
      \item \texttt{get\_function\_parameters}
      \item \texttt{get\_result\_type}
      \item \texttt{get\_storage\_class\_specifiers}
      \end{itemize}
    \end{column}
    \begin{column}{0.40\textwidth}
      \begin{itemize}
      \item \texttt{get\_instantiation}
      \item \texttt{get\_template}
      \item \texttt{get\_template\_parameters}
      \item \ldots
      \end{itemize}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Reverse reflection}
\begin{frame}
\frametitle{Reverse reflection}
  \begin{itemize}
    \item What happens when a metaobject is passed as arguments
      to \texttt{reflexpr}?
    \begin{itemize}
    \item If the metaobject is not a model of \texttt{Reversible} -- ill-formed.
    \item If the metaobject is a \texttt{Reversible} -- {\em reverse reflection}.
    \end{itemize}
  \end{itemize}
\Huge TODO
\end{frame}

\subsection{Context-dependent reflection}
\begin{frame}
\frametitle{Context-dependent reflection}
\Huge TODO
\end{frame}

\subsection{Identifier formatting}
\begin{frame}
\frametitle{Identifier formatting}
\Huge TODO
\end{frame}


\end{document}
