\section{Basic use cases}

This sections describes trivial use-cases for reflection.

\subsection{Portable (type) names}

One of the notorious problems of \verb@std::type_info@ is that the string
returned by its \verb@name@ member function is not standardized and is
not even guaranteed to return any meaningful, unique human-readable string,
at least not without demangling, which is platform specific.
Furthermore the returned string is not \verb@constexpr@ and cannot be
reasoned about at compile-time and is applicable only to types.
One other problem with \verb@typeid@ that it is not aware of \verb@typedef@s.
In some cases we would like to obtain the typedef name, instead of the
'real' name of the type or a class member or function parameter.

The ability to uniquely map any type used in a program to a human-readable,
portable, compile-time string has several use-cases described below.

The \meta{Named} concept from N4111 reflects named language constructs
and provides the \verb@base_name@ and \verb@full_name@ metafunctions,
returning their basic name without any qualifiers or decorations and a fully-qualified 
portable type name.

\subsection{Logging}

When logging the execution of functions (especialy templated ones) it is sometimes
desirable to also include the names of the parameter types or even the names of the parameters
and other variables.

The best we can do with just the \verb@std::type_info@ is the following:

\begin{minted}[tabsize=4]{cpp}
#if __PLATFORM_ABC__
std::string demangled_type_name(const char*) { /* implementation 1 */ }
#else if __PLATFORM_MNO__
std::string demangled_type_name(const char*) { /* implementation 2 */ }
#else if __PLATFORM_XYZ__
std::string demangled_type_name(const char*) { /* implementation N */ }
#else
std::string demangled_type_name(const char* mangled_name)
{
	// don't know how to demangle this; let's try our luck
	return mangled_name;
}
#endif

template <typename T>
T min(const T& a, const T& b)
{
	log()   << "min<"
	        << demangled_type_name(typeid(T).name())
	        << ">(" << a << ", " << b << ") = ";

	T result = a<b?a:b;

	log()   << result << std::endl;

	return result;
}

\end{minted}

Which may or may not work, depending on the platform.

With the help of reflection as proposed in N4111 we could do:

\begin{minted}[tabsize=4]{cpp}
template <typename T>
T min(const T& a, const T& b)
{
	log()   << "min<"
	        << full_name<reflected(T)>()
	        << ">(" << a << ", " << b << ") = ";

	T result = a<b?a:b;

	log()   << result << std::endl;

	return result;
}
\end{minted}

The \verb@__PRETTY_FUNCTION__@ macro generated by the compiler could be also
used in this case, but the format of the string which this macro expands into is not customizable
(which may be necessary for logs formatted in XML, JSON, etc.

A more elaborated output containing also the parameter names could be achieved
by using reflection:

\begin{minted}[tabsize=4]{cpp}
template <typename T>
T min(const T& a, const T& b)
{
	log()   << "function: min<"
	        << full_name<reflected(T)>()
	        << ">"
		<< std::endl
		<< base_name<reflected(a)>() << ": "
		<< a << std::endl
		<< base_name<reflected(b)>() << ": "
		<< b << std::endl;

	T result = a<b?a:b;

	log()   << base_name<reflected(result)>() << ": "
		<< b << std::endl;

	return result;
}
\end{minted}

It is true that the lines:
\begin{minted}[tabsize=4]{cpp}
		<< base_name<reflected(a)>() << ": "
		<< base_name<reflected(b)>() << ": "
\end{minted}

could be replaced by preprocessor stringization or just hard coded
strings, like

\begin{minted}[tabsize=4]{cpp}
		<< BOOST_PP_STRINGIZE(a) << ": "
		<< BOOST_PP_STRINGIZE(b) << ": "
\end{minted}

or

\begin{minted}[tabsize=4]{cpp}
		<< "a: "
		<< "b: "
\end{minted}

but the compiler would not force the programmer to change the macro parameter
or the content of the string the if the parameters \verb@a@ and \verb@b@ were renamed
for example to \verb@first@ and \verb@second@. If would enforce the change if
reflection was used.

Furthermore, if the \meta{Function} concept was implemented
and if it was possible to reflect the {\em 'current function'} (i.e. to get a \meta{Function}
from inside of a function body via some invocation of the reflection operator),
then even more would be possible; The function name and even the parameter names could
be obtained from reflection and encapsulated into a function.

\begin{minted}[tabsize=4]{cpp}
template <typename MetaFunction, typename ... P>
void log_function_exec(MetaFunction, const std::tuple<P&...>& params)
{
	log()   << "function: "
		<< base_name<MetaFunction>()
		<< std::endl;

	// obtain the MetaParameter(s) from the MetaFunction
	// and print them pairwise with the values from params.
	for_each<parameters<MetaFunction>>(
		[&params](auto meta_param)
		{
			typedef decltype(meta_param) MP;
			log()  << base_name<MP>() << ": "
			       << std::get<position<MP>::value>(params)
			       << std::endl;
		}
	);
}

template <typename T>
T min(T a, T b)
{
	log_function_exec(reflected(this::function), std::tie(a, b));
	/* ... */
}

template <typename T>
T max(T a, T b)
{
	log_function_exec(reflected(this::function), std::tie(a, b));
	/* ... */
}

template <typename T>
T avg(T a, T b)
{
	log_function_exec(reflected(this::function), std::tie(a, b));
	/* ... */
}
\end{minted}

This example used the following features:

\begin{itemize}
\item{function reflection,}
\item{function parameter reflection,}
\item{use of metaobject sequences,}
\item{use of the reflection operator,}
\item{base names and the \meta{Named} concept.}
\end{itemize}

\subsection{SQL schema generation}

We need to create an SQL/DDL (data definition language) script for creating a schema
with tables which will be storing the values of all structures in namespace C++ \verb@foo@
having names starting with \verb@persistent_@:

\begin{minted}[tabsize=4]{cpp}

const char* translate_to_sql(const std::string& type_name)
{
	if(type_name == "int")
		return "INTEGER";
	/* .. etc. */
}

template <typename MetaMemVar>
void create_table_column_from(MetaMemVar)
{
	if(!std::is_base_of<
		variable_tag,
		metaobject_category<MetaMemVar>
	>()) return;

	std::cout << base_name<MetaMemVar>() << " ";

	std::cout << translate_to_sql(base_name<type<MetaMemVar>());

	if(starts_with(base_name<MetaMemVar>(), "id_"))
	{
		std::cout << " PRIMARY KEY";
	}
	std::cout << std::endl;
}

template <typename MetaClass>
void create_table_from(MetaClass)
{
	if(!std::is_base_of<
		class_tag,
		metaobject_category<MetaClass>
	>()) return;

	std::cout << "CREATE TABLE "
	          << strip_prefix("persistent_", base_name<MetaClass>())
	          << "(" << std::endl;

	for_each<members<MetaClass>>(create_table_column_from);

	std::cout << ");"
}

template <typename MetaNamespace>
void create_schema_from(MetaNamespace)
{
	std::cout << "CREATE SCHEMA "
	          << base_name<MetaNamespace>()
	          << ";" << std::endl;

	for_each<members<MetaNamespace>>(create_table_from);
}

int main(void)
{
	create_schema_from(reflected(foo));
	return 0;
}

\end{minted}

This example shows the following features from N4111:

\begin{itemize}
\item{namespace reflection,}
\item{namespace member reflection,}
\item{class member reflection,}
\item{use of metaobject sequence,}
\item{metaobject categorization,}
\item{base names and the \meta{Named} concept.}
\end{itemize}

Furthermore reflection could be used to implement actual object-relational mapping,
together with a library like \verb@SOCI@, \verb@ODBC@, \verb@libpq@, etc.

\subsection{Simple serialization}

We need to serialize the instances of selected classes into a structured external format
like XML, JSON, XDR or even into a format like Graphviz dot for the purpose of creating
a visualization of a static class or dynamic object hierarchy or graph.

Reflection makes this task trivial\footnote{
Admittedly this is not the most clever XML schema ever devised, but let's stick to the basics.}:

\begin{minted}[tabsize=4]{cpp}

template <typename T>
void to_xml(const T& instance, std::true_type atomic)
{
	typedef reflected(T) MetaType;
	std::cout << "<" << base_name<MetaType>() << ">";
	std::cout << instance;
	std::cout << "</" << base_name<MetaType>() << ">";
}

template <typename T>
void to_xml(const T& instance)
{
	to_xml(instance, std::is_fundamental<T>());
}

template <typename T>
void to_xml(const T& instance, std::false_type atomic)
{
	typedef reflected(T) MetaType;
	std::cout << "<" << base_name<MetaType>() << ">";

	for_each<base_classes<MetaType>>(
		[](auto meta_inheritance)
		{
			typedef decltype(meta_inhertance) MetaInh;
			typedef original_type<base_class<MetaInh>>::type BT;

			to_xml(const BT&(instance));
		}
	);

	for_each<members<MetaType>>(
		[](auto meta_cls_mem)
		{
			typedef decltype(meta_cls_mem) MetaClsMem;
			typedef original_type<type<MetaClsMem>>::type MT;

			if(std::is_base_of<
				meta_variable_tag,
				metaobject_category<MetaClsMem>
			>())
			{
				auto mvp = pointer<MetaClsMem>::get();
				std::cout << "<" << base_name<MetaClsMem> << ">";
				to_xml(instance.*mvp);
				std::cout << "</" << base_name<MetaClsMem> << ">";
			}
		}
	);

	std::cout << "</" << base_name<MetaType>() << ">";
}

\end{minted}

Where necessary explicit specializations can override the generic implementation:

\begin{minted}[tabsize=4]{cpp}

template <typename Bool>
void to_xml(const std::string& instance, Bool)
{
	std::cout << "<string>";
	std::cout << instance;
	std::cout << "</string>";
}

\end{minted}

This use-case shows the following:

\begin{itemize}
\item{class member reflection,}
\item{inheritance reflection,}
\item{class member variable reflection,}
\item{use of metaobject sequences,}
\item{use of the interface of various metaobjects,}
\item{use of the reflection operator,}
\item{metaobject categorization,}
\item{base names and the \meta{Named} concept.}
\end{itemize}


\subsection{Implementing delegation or decorators}

We need to create a decorator class, which wraps an instance of another
class, implements similar interface as the original class, writes info about
each member function call into a log and then delegates the call to the private member object:

\begin{minted}[tabsize=4]{cpp}

class foo
{
public:
	void f1(void);

	int f2(int a, int b);

	double f3(float a, long b, double c, const std::string& d);
};

class logging_foo
{
private:
	foo _obj;
	loglib::log_sink _log;

	template <typename MetaFunction, typename ... P>
	void _do_log_call(const P&...);
public:
	void f1(void)
	{
		_do_log_call<reflected(this::function)>();
		_obj.f1();
	}

	int f2(int a, int b);
	{
		_do_log_call<reflected(this::function)>();
		return _obj.f2(a, b);
	}

	double f3(float a, long b, double c, const std::string& d);
	{
		_do_log_call<reflected(this::function)>();
		return _obj.f3(a, b, c, d);
	}
};

\end{minted}

Obviously the definition of \verb@logging_foo@ is very repetitive and if this
pattern is recurring in the code it may lead to subtle, hard to track bugs,
so we may wish to automate the implementation.

Reflection to the rescue!

\begin{minted}[tabsize=4]{cpp}

template <typename Wrapped>
class logging_base
{
protected:
	Wrapped _obj;
	loglib::log_sink _log;

	template <typename MetaFunction, typename ... P>
	void _do_log_call(const P&...);
};

\end{minted}

\verb@logging_base@ is a common virtual base class holding the wrapped object
and the log sink.

\begin{minted}[tabsize=4]{cpp}

template <typename Wrapped, typename MetaFunction>
class logging_helper
 : virtual public logging_base<Wrapped>
{
public:
	template <typename ... P>
	auto identifier(base_name<MetaFunction>::value)(P&& ... p)
	{
		this->_do_log_call<MetaFunction>(std::forward<P>(p)...);

		auto mfp = pointer<MetaFunction>::get();

		return (this->_obj.*mfp)(std::forward<P>(p)...);
	}
};

\end{minted}

\verb@logging_helper@ is a unit implementing the delegation of a single function
call from the interface of the \verb@Wrapped@ class. 

The \verb@identifier@ operator is used here to define the name of the member function
to be the same as the name of the wrapped function.

If the idea of the \verb@identifier@ operator is scrapped, it would still be doable
in terms of the \verb@named_mem_var@ template as defined in N4111, or some variation
on that theme.

\begin{minted}[tabsize=4]{cpp}

template <typename Wrapped, typename ... MetaFunctions>
class logging_helpers
 : public logging_helper<Wrapped, MetaFunctions>...
{ };

\end{minted}

\verb@logging_helpers@ inherits from multiple \verb@logging_helper@ units
each having a single \meta{Function} reflecting respective member functions
of the \verb@Wrapper@ class.

\begin{minted}[tabsize=4]{cpp}

template <typename Wrapped, typename MetaFunctionSeq, typename IdxSeq>
class logging_impl;

template <typename Wrapped, typename MetaFunctionSeq, std::size_t ... I>
class logging_impl<Wrapped, MetaFunctionSeq, std::index_sequence<I...>>
 : public logging_helpers<Wrapped, at<MetaFunctionSeq, I>...>
{ };

\end{minted}

\verb@logging_impl@ uses a standard \verb@index_sequence@ to extract the
individual \meta{Functions} from the metafunction sequence and passes them
to \verb@logging_helpers@ as a parameter pack.


\begin{minted}[tabsize=4]{cpp}

template <typename Wrapped>
class logging
 : public logging_impl<
	Wrapped,
	members<reflected(Wrapped)>,
	std::make_index_sequence<size<members<reflected(Wrapped)>>::value>
>
{ };

typedef logging<foo> logging_foo;

\end{minted}

The \verb@logging@ template makes the use of \verb@logging_impl@ convenient.

Note that the metaobject sequence 'returned' by \verb@members<...>@ should
be filtered to contain only \meta{Function}s.

\begin{itemize}
\item{class member reflection,}
\item{class member function reflection,}
\item{use of the reflection operator,}
\item{use of the \verb@identifier@ operator or the \verb@named_mem_var@ templates.}
\end{itemize}

\subsubsection{Source text-based metaprogramming}

In scripting languages metaprogramming often takes the form of dynamically creating
a new script purely through text operations followed by the execution of that script.

While using this approach is more complicated with compiled languages it is not
unheard of. A C++ source can be created by a program in C++, compiled by a compiler
(invoked from that same or in a different program) into a shared library and then
dynamically loaded and executed.

In some cases this approach could be used to generate code on a local machine,
which is then compiled and executed on a remote machine with a different architecture.

\begin{minted}[tabsize=4]{cpp}

class foo64bit
{
/* ... */
};

class foo32bit
{
/* ... */
};

#if __THIS_IS_64BIT_ARCH
typedef foo64bit default_foo;
#else
typedef foo32bit default_foo;
#endif

struct plugin
{
	virtual void process_foo(default_foo&) = 0;
	/* ... */
};

\end{minted}

We want to programatically create a new logging\footnote{
We're again trying to stick to the basics, here. Much more complicated
examples could be devised.
} implementation of \verb@plugin@
and we don't want to rewrite this program every time
the interface is updated.

Furthermore it is possible that we will be generating the code
on a 32-bit machine and then compiling and executing it on a 64-bit machine
or vice-versa.

\begin{minted}[tabsize=4]{cpp}

template <typename MetaFunction>
void print_func_impl(MetaFunction)
{
	using std::cout;
	using std::endl;

	// the result can have a typedef-ined type
	// and we want to print here the typedef name
	cout << base_name<result_type<MetaFunction>>() << " ";
	cout << base_name<MetaFunction>() << "(";

	for_each<parameters<MetaFunction>>(
		[](auto meta_param)
		{
			typedef decltype(meta_param) MetaParam;
			if(position<MetaParam>() > 0)
			{
				cout << ", ";
			}
			// the parameter can have a typedef-ined type
			// and we want to print here the typedef name
			cout << base_name<type<MetaParam>>() << " ";
			cout << base_name<MetaParam>();
		}
	);

	cout << base_name<MetaFunction>() << ")";
	cout << " override" << endl;
	cout << "{" << endl;
	cout << "  _do_log_call<MetaFunction>(" << endl;

	for_each<parameters<MetaFunction>>(
		/* Print out a parameter list for the call */
	);

	cout << "  );" << endl;

	/* Print out the rest of the implementation */

	cout << "}" << endl;
}

void main(void)
{
	using std::cout;
	using std::endl;

	cout << "#include <foo/plugin.hpp>" << endl;
	/* etc. */

	cout << "class logging_plugin" << endl;
	cout << " : virtual public plugin" << endl;
	cout << "{" << endl;
	cout << "private:" << endl;
	cout << "  template <typename MetaFunction, typename ... P>" << endl;
	cout << "  void _do_log_call(const P&...);" << endl;
	cout << "public:" << endl;

	for_each<members<mirrored(plugin)>>(print_func_impl);

	cout << "};" << endl;
	return 0;
}

\end{minted}

The example above could be semi-automated using the preprocessor
and (demangled) \verb@type_info::name@. The problem is that
\verb@type_info@ is not aware of the fact that the \verb@default_foo@
parameter type is a typedef and it would instead return either
\verb@"foo64bit"@ or \verb@"foo32bit"@ based on the architecture
on which the script was generated.

In N4111 it is proposed that reflection is aware of \verb@typedef@s and distinguishes between
\verb@typedef@s and their 'underlying types'.

\subsection{Cross-cutting aspects}

We need to execute the same action (or a set of actions) at the entry of or at the exit from the body of
a function (from a set of multiple functions meeting some conditions) each time it is called.

The action may be related to logging, debugging, profiling, but also access control, etc.
The condition which selects the functions for which the action is invoked might be something like:
\begin{itemize}
\item each member function of a class,
\item each function defined in a namespace,
\item each function returning values of a particular type or having a particular set of parameters,
\item each function whose name matches a search expression,
\item each function declared in a particular source file,
\item etc. and various combinations of the above.
\end{itemize}

It may not be possible to tell in advance the relations between the aspects and the individual functions
or these relations may change between builds or build configurations.
Furthermore we want to be able to quickly change the assignment of actions to functions in one
place instead of going through the whole project source which may consists of dozens or even hundreds of files.

We want for example temporarily enable logging of the entry and exit of each member function of class \verb@foo@,
or we need to count the number of invocations of functions defined in the \verb@bar@ namespace with
names not starting with an underscore, or we want to throw the \verb@not_logged_in@ exception at the entry
of each member function of class \verb@secure@ if the global \verb@user_logged_in@ function returns \verb@false@.

Without reflection something like this could be implemented in the following way:

\begin{minted}[tabsize=4]{cpp}

class logging_aspect
{
public:
	template <typename ... P>
	logging_aspect(const char* func_name, P&&...)
	{
		// write to clog
	}
};

class profiling_aspect
{
	/* ... */
};

class authorization_aspect
{
public:
	template <typename ... P>
	authorization_aspect(const char* func_name, P&&...)
	{
		if(contains(func_name, "secure"))
		{
			if(!::is_user_logged_in())
			{
				throw not_authorized(func_name);
			}
		}
	}
};

template <typename RV, typename ... P>
class func_aspects
 : logging_aspect
 , profiling_aspect
 , authorization_aspect
/* ... etc. ... */
{
public:
	func_aspects(
		const char* name,
		const char* file,
		unsigned line,
		P&&... args
	): logging_aspect(name, file, line, args...)
	 , profiling_aspect(name, file, line, args...)
	 , authorization_aspect(name, file, line, argc...)
	/* ... etc. ... */
	{ }
};

template <typename RV, typename ... P>
func_aspects<RV, P...>
make_func_aspects(
	const char* name,
	const char* file,
	unsigned line,
	P&&...args
);


void func1(int a, int b)
{
	auto _fa = make_func_aspects<void>(
		__func__,
		__FILE__,
		__LINE__,
		a, b
	);
	/* function body */
}

double func2(double a, float b, long c)
{
	auto _fa = make_func_aspects<double>(
		__func__,
		__FILE__,
		__LINE__,
		a, b, c
	);
	/* function body */
}

namespace foo {

long func3(int x)
{
	auto _fa = make_func_aspects<long>(
		__func__,
		__FILE__,
		__LINE__,
		x
	);
	/* function body */
}

} // namespace foo
\end{minted}

Obviously this is very repetitive and it can get quite tedious and error-prone
to supply all this information to the aspects in each function manually.
Also if the signature or the name of the function changes the construction
of the \verb@func_aspects@ instance must be updated accordingly.
With the help of reflection things can be simplified considerably:

\begin{minted}[tabsize=4]{cpp}

template <typename MetaFunction>
class func_aspects
 : logging_aspect<MetaFunction>
 , profiling_aspect<MetaFunction>
 , authorization_aspect<MetaFunction>
/* ... etc. ... */
{
public:
};

void func1(int a, int b)
{
	func_aspects<mirrored(this::function)> _fa;
	/* function body */
}

double func2(double a, float b, long c)
{
	func_aspects<mirrored(this::function)> _fa;
	/* function body */
}

namespace foo {

long func3(int x)
{
	func_aspects<mirrored(this::function)> _fa;
	/* function body */
}

} // namespace foo

\end{minted}

In this case the same expression is used in all functions
regardless of their name and signature and the aspects get all the information
they require from the metaobject reflecting the function. All the data
obtained from the metaobjects is available at compile-time so various
specializations of the aspect classes can be implemented as required.

This same technique could also be used with instances of classes:

\begin{minted}[tabsize=4]{cpp}

template <typename MetaClass>
class class_aspects
 : logging_aspects<MetaClass>
/* ... etc. ... */
{
public:
	class_aspects(typename original_type<MetaClass>::type* that);
};

class cls1
{
private:
	int member1;
	/* ... other members ... */
	class_aspect<mirrored(this::class)> _ca;
public:
	cls1(void)
	 : member1(...)
	 , _ca(this)
	{ }
};

\end{minted}

Aspects like these could also be used for logging, monitoring of object instantation,
leak detection, etc.
