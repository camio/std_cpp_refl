\section{Basic use cases}

This sections describes trivial use-cases for reflection.

\subsection{Portable (type) names}

One of the notorious problems of \verb@std::type_info@ is that the string
returned by its \verb@name@ member function is not standardized and is
not even guaranteed to return any meaningful, unique human-readable string,
at least not without demangling, which is platform specific.
Furthermore the returned string is not \verb@constexpr@ and cannot be
reasoned about at compile-time and is applicable only to types.

The ability to uniquely map any type used in a program to a human-readable,
portable, compile-time string has several use-cases described below.

The \meta{Named} concept from N4111 reflects named language constructs
and provides the \verb@base_name@ and \verb@full_name@ metafunctions,
returning their basic name without any qualifiers or decorations and a fully-qualified 
portable type name.

\subsubsection{Logging}

When logging the execution of functions (especialy templated ones) it is sometimes
desirable to also include the names of the parameter types or even the names of the parameters
and other variables.

The best we can do with just the \verb@std::type_info@ is the following:

\begin{minted}{cpp}
#if __PLATFORM_ABC__
std::string demangled_type_name(const char*) { /* implementation 1 */ }
#else if __PLATFORM_MNO__
std::string demangled_type_name(const char*) { /* implementation 2 */ }
#else if __PLATFORM_XYZ__
std::string demangled_type_name(const char*) { /* implementation N */ }
#else
std::string demangled_type_name(const char* mangled_name)
{
	// don't know how to demangle this; let's try our luck
	return mangled_name;
}
#endif

template <typename T>
T min(const T& a, const T& b)
{
	log()   << "min<"
	        << demangled_type_name(typeid(T).name())
	        << ">(" << a << ", " << b << ") = ";

	T result = a<b?a:b;

	log()   << result << std::endl;

	return result;
}

\end{minted}

Which may or may not work, depending on the platform.

With the help of reflection as proposed in N4111 we could do:

\begin{minted}{cpp}
template <typename T>
T min(const T& a, const T& b)
{
	log()   << "min<"
	        << full_name<reflected(T)>()
	        << ">(" << a << ", " << b << ") = ";

	T result = a<b?a:b;

	log()   << result << std::endl;

	return result;
}
\end{minted}

The \verb@__PRETTY_FUNCTION__@ macro generated by the compiler could be also
used in this case, but the format of the string which this macro expands to is not customizable
(which may be necessary for logs formatted in XML, JSON, etc.

A more elaborated output containing also the parameter names could be achieved
by using reflection:

\begin{minted}{cpp}
template <typename T>
T min(const T& a, const T& b)
{
	log()   << "function: min<"
	        << full_name<reflected(T)>()
	        << ">"
		<< std::endl
		<< base_name<reflected(a)>() << ": "
		<< a << std::endl
		<< base_name<reflected(b)>() << ": "
		<< b << std::endl;

	T result = a<b?a:b;

	log()   << base_name<reflected(result)>() << ": "
		<< b << std::endl;

	return result;
}
\end{minted}

It is true that the lines:
\begin{minted}{cpp}
		<< base_name<reflected(a)>() << ": "
		<< base_name<reflected(b)>() << ": "
\end{minted}

could be replaced by preprocessor stringization or just hard coded
strings, like

\begin{minted}{cpp}
		<< BOOST_PP_STRINGIZE(a) << ": "
		<< BOOST_PP_STRINGIZE(b) << ": "
\end{minted}

or

\begin{minted}{cpp}
		<< "a: "
		<< "b: "
\end{minted}

but the compiler would not force the programmer to change the macro parameter
or the content of the string the if the parameters \verb@a@ and \verb@b@ were renamed
for example to \verb@first@ and \verb@second@. If would enforce the change if
reflection was used.

Furthermore, if the \meta{Function} concept was implemented
and if it was possible to reflect the {\em 'current function'} (i.e. to get a \meta{Function}
from inside of a function body via some invocation of the reflection operator),
then even more would be possible; The function name and even the parameter names could
be obtained from reflection and encapsulated into a function.

\begin{minted}{cpp}
template <typename MetaFunction, typename ... P>
void log_function_exec(MetaFunction, const std::tuple<P&...>& params)
{
	log()   << "function: "
		<< base_name<MetaFunction>()
		<< std::endl;

	// obtain the MetaParameter(s) from the MetaFunction
	// and print them pairwise with the values from params.
	for_each<parameters<MetaFunction>>(
		[&params](auto meta_param)
		{
			typedef decltype(meta_param) MP;
			log()  << base_name<MP>() << ": "
			       << std::get<position<MP>::value>(params)
			       << std::endl;
		}
	);
}

template <typename T>
T min(T a, T b)
{
	log_function_exec(reflected(this_function), std::tie(a, b));
	/* ... */
}

template <typename T>
T max(T a, T b)
{
	log_function_exec(reflected(this_function), std::tie(a, b));
	/* ... */
}

template <typename T>
T avg(T a, T b)
{
	log_function_exec(reflected(this_function), std::tie(a, b));
	/* ... */
}
\end{minted}

\subsubsection{Object-relational mapping}

We need to create an SQL/DDL (data definition language) script for creating a schema
with tables which will be storing the values of all structures in namespace C++ \verb@foo@
having names starting with \verb@persistent_@:

\begin{minted}{cpp}

const char* translate_to_sql(const std::string& type_name)
{
	if(type_name == "int")
		return "INTEGER";
	/* .. etc. */
}

template <typename MetaMemVar>
void create_table_column_from(MetaMemVar)
{
	if(!std::is_base_of<
		variable_tag,
		metaobject_category<MetaMemVar>
	>()) return;

	std::cout << base_name<MetaMemVar>() << " ";

	std::cout << translate_to_sql(base_name<type<MetaMemVar>());

	if(starts_with(base_name<MetaMemVar>(), "id_"))
	{
		std::cout << " PRIMARY KEY";
	}
	std::cout << std::endl;
}

template <typename MetaClass>
void create_table_from(MetaClass)
{
	if(!std::is_base_of<
		class_tag,
		metaobject_category<MetaClass>
	>()) return;

	std::cout << "CREATE TABLE "
	          << strip_prefix("persistent_", base_name<MetaClass>())
	          << "(" << std::endl;

	for_each<members<MetaClass>>(create_table_column_from);

	std::cout << ");"
}

template <typename MetaNamespace>
void create_schema_from(MetaNamespace)
{
	std::cout << "CREATE SCHEMA "
	          << base_name<MetaNamespace>()
	          << ";" << std::endl;

	for_each<members<MetaNamespace>>(create_table_from);
}

int main(void)
{
	create_schema_from(reflected(foo));
	return 0;
}

\end{minted}

\subsubsection{Simple serialization}




\subsection{Enumeration of base classes}

\subsection{Enumeration of scope members}

\subsection{Turning compile-time strings into identifiers}

