\section{Introduction}

There is a wide range of computer programming scenarios in which
the programmer has to (or had to) manualy implement some generic boilerplate
code doing the same thing on multiple different types (or other language constructs,
like namespaces, constructors, etc.). For example accessing member variables or
calling free or member functions and operators in an uniform
manner, converting data between the language's intrinsic representation and
external formats, delegation or some of the other
established design patterns, etc.

With the right tools most of these tasks could be properly algorithmized,
encapsulated into some form of parametric {\em 'callable'} and then invoked
with appropriate arguments.

The C/C++ preprocessor and C++'s templates were devised to help dealing
with some of such cases and later gave rise to particular forms of metaprogramming,
which have since become relatively popular. However, while preprocessor and template-based
metaprogramming is being put to good use by more and more libraries and applications written
in C++, we are starting to hit the limits of these tools.

The limits stem from the fact, that while we can now use the C++'s type system
as a (meta)programming language of its own and a C++ compiler as its interpreter
and write complicated metaprograms automatically generating a lot of code
which we previously had to write manually, the programmer still needlessly has to do
a lot of things manually. Just to mention a few things; if we want portable type names,
we usually have to hardcode them, if we want to create an identifier programmatically
we need preprocessor token pasting, we cannot programmatically enumerate all member
variables or base classes of a class, all operators working on a particular type, etc.

A C++ compiler processing a translation unit has access to a large amount
of very useful metadata, but unfortunately shares only a tiny amount of it
with the programmer. Not so long ago the {\em type-traits} -- introspection primitives,
many of which rely on some sort of compiler 'magic' (a.k.a. reflection) were introduced.
Before that the only 'reflection-facility' in C++ was the \verb@typeid@ operator.

The aim of this paper is to show that we can and should be able to get much more
information from the compiler and why that would be useful. Since this paper is a follow-up
to N3996 and N4111, it also indicates how the metaobjects proposed in N4111 would
be usable in the individual use-cases.

\subsection{Additions to N4111}

The examples below use several features not described in N4111 (these will be added
in the next revision of that paper):

\subsubsection{For each element in Metaobject sequence}

Template function \verb@for_each@, should be defined for every metaobject sequence
and should call the specified unary functor taking values of types conforming to
the same metaobject concept as the elements of the metaobject sequence as arguments.

\begin{minted}{cpp}
template <typename MetaobjectSequence, typename UnaryFunc>
void for_each(UnaryFunc func)
{
	/* call func on each element in the sequence */
}
\end{minted}

The interface of \meta{objectSequence} as defined in N4111 should be enough
to define a single generic implementation of this function without the need
to write specialization for every type modelling this concept.

\subsubsection{Position of a base in the list of base classes}

For every model of \meta{Inheritance} the \verb@position@ template should be defined as:

\begin{minted}{cpp}
template <>
struct position<MetaInheritance>
 : integral_constant<std::size_t, I>
{ };
\end{minted}

Where \verb@I@ is the zero-based index of the base class in the inheritance list of a derived class
reflected by the \meta{Inheritance}.

\subsubsection{Turning compile-time strings into identifiers}

Inspired by the idea of {\em name literals} as mentioned on the WG mailing list,
we suggest to add a new functionality to the core language, allowing to specify
identifiers as compile-time constant C-string literal expression, i.e. expressions
evaluating into values of \verb@constexpr const char [N]@.

This could be implemented either by using a new operator (or recycling an old one),
or maybe by using generalized attributes.
In the examples below the \verb@identifier@ operator is used, but we do not have
any strong preference for the name of this operator.

For example:

\begin{minted}{cpp}

identifier("int") identifier("main")(
	int idenitifier("argc"),
	const identifier("char")* identifier("argv")
)
{
	using namespace identifier("std");
	for(int i=0; i<argc; ++i)
	{
		cout << argv[i] << endl;
	}
	return 0;
}

\end{minted}

would be equivalent to

\begin{minted}{cpp}
int main(int argc, const char* argv)
{
	using namespace std;
	/* ... */
}
\end{minted}

The content of the string literal passed as the argument to \verb@identifier@
should be encoded in the source character set and subject to the same restrictions
which are placed on identifiers.

The idea is to replace preprocessor token pasting with much more flexible constexpr C++ expressions.
Adding this feature would also allow to remove the \verb@named_mem_var@ and
\verb@named_typedef@ metafunctions which were in N4111 defined as part of
the interface of \meta{Named}.

This addition has the potential to complicate the processing of a translation unit
by the compiler and would logically fit somewhere between phases 6 and 8 as described
in the standard. If the use of regular templates for the purpose of creating the
constexpr identifier strings would be too complicated to implement, phase 6 could
be extended to allow simple compile-time text manipulation (comparison, concatenation,
substrings, etc.) by a set of dedicated functions.

The following sections describe several use cases for this feature.

