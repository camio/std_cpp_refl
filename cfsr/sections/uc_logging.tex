\subsection{Logging}

When logging the execution of functions (especialy templated ones) it is sometimes
desirable to also include the names of the parameter types or even the names of the parameters
and other variables.

The best we can do with just the \verb@std::type_info@ is the following:

\begin{minted}[tabsize=4]{cpp}
#if __PLATFORM_ABC__
std::string demangled_type_name(const char*) { /* implementation 1 */ }
#else if __PLATFORM_MNO__
std::string demangled_type_name(const char*) { /* implementation 2 */ }
#else if __PLATFORM_XYZ__
std::string demangled_type_name(const char*) { /* implementation N */ }
#else
std::string demangled_type_name(const char* mangled_name)
{
	// don't know how to demangle this; let's try our luck
	return mangled_name;
}
#endif

template <typename T>
T min(const T& a, const T& b)
{
	log()   << "min<"
	        << demangled_type_name(typeid(T).name())
	        << ">(" << a << ", " << b << ") = ";

	T result = a<b?a:b;

	log()   << result << std::endl;

	return result;
}

\end{minted}

Which may or may not work, depending on the platform.

With the help of reflection as proposed in N4111 we could do:

\begin{minted}[tabsize=4]{cpp}
template <typename T>
T min(const T& a, const T& b)
{
	log()   << "min<"
	        << full_name<reflected(T)>()
	        << ">(" << a << ", " << b << ") = ";

	T result = a<b?a:b;

	log()   << result << std::endl;

	return result;
}
\end{minted}

The \verb@__PRETTY_FUNCTION__@ macro generated by the compiler could be also
used in this case, but the format of the string which this macro expands into is not customizable
(which may be necessary for logs formatted in XML, JSON, etc.

A more elaborated output containing also the parameter names could be achieved
by using reflection:

\begin{minted}[tabsize=4]{cpp}
template <typename T>
T min(const T& a, const T& b)
{
	log()   << "function: min<"
	        << full_name<reflected(T)>()
	        << ">"
		<< std::endl
		<< base_name<reflected(a)>() << ": "
		<< a << std::endl
		<< base_name<reflected(b)>() << ": "
		<< b << std::endl;

	T result = a<b?a:b;

	log()   << base_name<reflected(result)>() << ": "
		<< b << std::endl;

	return result;
}
\end{minted}

It is true that the lines:
\begin{minted}[tabsize=4]{cpp}
		<< base_name<reflected(a)>() << ": "
		<< base_name<reflected(b)>() << ": "
\end{minted}

could be replaced by preprocessor stringization or just hard coded
strings, like

\begin{minted}[tabsize=4]{cpp}
		<< BOOST_PP_STRINGIZE(a) << ": "
		<< BOOST_PP_STRINGIZE(b) << ": "
\end{minted}

or

\begin{minted}[tabsize=4]{cpp}
		<< "a: "
		<< "b: "
\end{minted}

but the compiler would not force the programmer to change the macro parameter
or the content of the string the if the parameters \verb@a@ and \verb@b@ were renamed
for example to \verb@first@ and \verb@second@. If would enforce the change if
reflection was used.

Furthermore, if the \meta{Function} concept was implemented
and if it was possible to reflect the {\em 'current function'} (i.e. to get a \meta{Function}
from inside of a function body via some invocation of the reflection operator),
then even more would be possible; The function name and even the parameter names could
be obtained from reflection and encapsulated into a function.

\begin{minted}[tabsize=4]{cpp}
template <typename MetaFunction, typename ... P>
void log_function_exec(MetaFunction, const std::tuple<P&...>& params)
{
	log()   << "function: "
		<< base_name<MetaFunction>()
		<< std::endl;

	// obtain the MetaParameter(s) from the MetaFunction
	// and print them pairwise with the values from params.
	for_each<parameters<MetaFunction>>(
		[&params](auto meta_param)
		{
			typedef decltype(meta_param) MP;
			log()  << base_name<MP>() << ": "
			       << std::get<position<MP>::value>(params)
			       << std::endl;
		}
	);
}

template <typename T>
T min(T a, T b)
{
	log_function_exec(reflected(this::function), std::tie(a, b));
	/* ... */
}

template <typename T>
T max(T a, T b)
{
	log_function_exec(reflected(this::function), std::tie(a, b));
	/* ... */
}

template <typename T>
T avg(T a, T b)
{
	log_function_exec(reflected(this::function), std::tie(a, b));
	/* ... */
}
\end{minted}

This example used the following features:

\begin{itemize}
\item{function reflection,}
\item{function parameter reflection,}
\item{use of metaobject sequences,}
\item{use of the reflection operator,}
\item{base names and the \meta{Named} concept.}
\end{itemize}
