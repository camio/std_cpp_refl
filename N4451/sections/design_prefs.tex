\section{Design preferences}

When designing the reflection facility we did so with
the following principles\footnote{Some of the principles
apply only to the whole reflection facility as it is envisioned
to look in the future, not to the current limited subset proposed
in this paper.} in mind.

\subsection{Consistency}

The reflection facility as a whole
should be consistent, instead of being composed of ad-hoc,
individually-designed parts.

\subsection{Reusability}

The provided metadata should be reusable
in many situations and for many different purposes. It should not focus only
on the obvious use cases. This is closely related to {\em completeness} (below).

\subsection{Flexibility}

The basic reflection and the libraries
built on top of it should be designed
in a way that they are eventually usable during both compile-time
and run-time and under various paradigms (object-oriented, functional, etc.),
depending on the application needs.

\subsection{Encapsulation}

The metadata should not be exposed directly to the user by compiler built-ins, etc.
Instead it should be accessible through conceptually well-defined interfaces.

\subsection{Stratification}

Reflection should be non-intrusive
and the meta-level should be separated from the base-level language
constructs it reflects. Also, reflection should not be implemented
in a all-or-nothing manner. Things that are not needed for a particular application,
should not generally be compiled-into such application.

\subsection{Ontological correspondence}

The meta-level facilities should
correspond to the ontology of the base-level C++ language constructs
which they reflect. This basically means that all existing language
features should be reflected and new ones should not be invented.

\subsection{Completeness}

When finalized, the proposed reflection facility should
provide as much useful metadata as possible, including various specifiers,
(like constness, storage-class, access, etc.), namespace members,
enumerated types, iteration of namespace members and much more,
in order to be useful in a wide range of scenarios.

\subsection{Ease of use}

Although reflection-based metaprogramming
allows to implement very complicated things, simple things
should be kept simple.

\subsection{Cooperation with rest of the standard and other librares}

Reflection should be easily
usable with the existing introspection facilites (like \verb@type_traits@)
already provided by the standard library and with other libraries.

\subsection{Extensibility}

The programmers should be able to define their own models of metaobject concepts
and these should be usable with the rest of the metaobjects provided by the
compiler. This way if some of the metaobjects generated by the compiler are not
suitable for a particular purpose they can be individually replaced with
hand-coded variants.
