\subsection{Categorization and Traits}

In order to provide means for distinguishing between regular types
and metaobjects generated by the compiler,
the \verb@is_metaobject@ trait should be added to the \verb@std@ namespace\footnote{
even if a nested namespace like \texttt{std::meta} is used for everything else}
and should inherit from \verb@true_type@ for metaobjects\footnote{types generated
by the compiler providing metadata} and from \verb@false_type@
for non-metaobjects\footnote{native or user defined types}:

\begin{minted}{cpp}
template <typename T>
struct is_metaobject
 : false_type
{ };
\end{minted}

\subsubsection{Metaobject category tags}
\label{metaobject-category-tags}

To distiguish between various metaobject kinds\footnote{metaobjects satisfying different concepts
as described below} a set of tag \verb@struct@s indicating the metaobject kind
should be added:

\begin{minted}{cpp}

struct namespace_tag
{
	typedef namespace_tag type;
};

struct global_scope_tag
{
	typedef global_scope_tag type;
};

struct type_tag
{
	typedef type_tag type;
};

struct typedef_tag
{
	typedef typedef_tag type;
}; 

struct class_tag
{
	typedef class_tag type;
};

struct enum_tag
{
	typedef enum_tag type;
};

struct enum_class_tag
{
	typedef enum_class_tag type;
};

struct variable_tag
{
	typedef variable_tag type;
};

\end{minted}

These tags are referred-to as \verb@MetaobjectCategory@:

