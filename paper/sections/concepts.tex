\section{Metaobject concepts}

We propose that the basic metadata describing a program written
in C++ should be made available through a set of {\em anonymous} types
and related functions and templates
defined by the compiler. These types should describe various program
constructs like, namespaces, types, typedefs, classes, their member variables
(member data), member functions, inheritance, templates, template parameters,
enumerated values, etc.

The compiler should generate metadata for the program constructs defined
in the currently processed translation unit. Indexed sets (ranges) of metaobjects,
like scope members, parameters of a function, etc. should be listed
in the order of appearance in the processed source code.

Since we want the metadata to be available at compile-time,
different base-level constructs should be reflected by
{\em "statically" different} metaobjects and thus by {\em different} types.
For example a metaobject reflecting the global scope namespace should
be a different {\em type} than a metaobject reflecting the \verb@std@
namespace, a metaobject reflecting the \verb@int@ type should
have a different type then a metaobject reflecting the \verb@double@
type, a metaobject reflecting \verb@::foo(int)@ function should
have a different type than a metaobject reflecting \verb@::foo(double)@,
function, etc.

In a manner of speaking these special types (metaobjects) should become
"instances" of the meta-level concepts (static interfaces which
should not exist as concrete types, but rather only at the
"specification-level" similar for example to the iterator concepts).
This section describes a set of metaobject concepts,
their interfaces, tag types for metaobject classification and
functions (or operators) providing access to the metaobjects.

This section conceptualy describes the requirements that various metaobjects
need to satisfy in order to be considered models of the individual
concepts.

\subsection{Categorization and Traits}

In order to provide means for distinguishing between regular types
and metaobjects generated by the compiler,
the \verb@is_metaobject@ trait should be added
and should "return" \verb@true_type@ for metaobjects (types generated
by the compiler providing metadata) and \verb@false_type@
for non-metaobjects (native or user defined types):

\begin{lstlisting}
template <typename T>
struct is_metaobject
 : false_type
{ };
\end{lstlisting}

\subsubsection{Metaobject category tags}
\label{metaobject-category-tags}

To distiguish between various metaobject kinds (satisfying different concepts
as described below) a set of tag \verb@struct@s (indicating the kind of the metaobject)
should be added:

\begin{lstlisting}
struct specifier_tag
{
	typedef specifier_tag type;
};

struct namespace_tag
{
	typedef namespace_tag type;
};

struct global_scope_tag
{
	typedef global_scope_tag type;
};

struct type_tag
{
	typedef type_tag type;
};

struct typedef_tag
{
	typedef typedef_tag type;
}; 

struct class_tag
{
	typedef class_tag type;
};

struct function_tag
{
	typedef function_tag type;
};

struct constructor_tag
{
	typedef constructor_tag type;
};

struct operator_tag
{
	typedef operator_tag type;
};

struct overloaded_function_tag
{
	typedef overloaded_function_tag type;
};

struct enum_tag
{
	typedef enum_tag type;
};

struct enum_class_tag
{
	typedef enum_class_tag type;
};

struct inheritance_tag
{
	typedef inheritance_tag type;
};

struct constant_tag
{
	typedef constant_tag type;
};

struct variable_tag
{
	typedef variable_tag type;
};

struct parameter_tag
{
	typedef parameter_tag type;
};
\end{lstlisting}

These tags are referred-to as \verb@MetaobjectCategory@ below:

\subsubsection{Specifier category tags}
\label{specifier-category-tags}

Similar to the \hyperref[metaobject-category-tags]{metaobject tag} types,
a set of tag types for individual C++ specifier keywords should be defined:

\begin{lstlisting}
struct extern_tag
{
	typedef extern_tag type;
};

struct static_tag
{
	typedef static_tag type;
};

struct mutable_tag
{
	typedef mutable_tag type;
};

struct register_tag
{
	typedef register_tag type;
};

struct thread_local_tag
{
	typedef thread_local_tag type;
};

struct const_tag
{
	typedef const_tag type;
};

struct virtual_tag
{
	typedef virtual_tag type;
};

struct private_tag
{
	typedef private_tag type;
};

struct protected_tag
{
	typedef protected_tag type;
};

struct public_tag
{
	typedef public_tag type;
};

struct class_tag
{
	typedef class_tag type;
};

struct struct_tag
{
	typedef struct_tag type;
};

struct union_tag
{
	typedef union_tag type;
};

struct enum_tag
{
	typedef enum_tag type;
};

struct enum_class_tag
{
	typedef enum_class_tag type;
};

struct constexpr_tag
{
	typedef constexpr_tag type;
};

\end{lstlisting}

These tags are referred-to as \verb@SpecifierCategory@ below:

\subsection{Metaobject}
\label{concept-Metaobject}

A {\em Metaobject} is a stateless anonymous type generated by the compiler which
provides metadata reflecting a specific program feature. Each metaobject
should satisfy the following:

The \verb@is_metaobject@ template should return \verb@true_type@.

\begin{lstlisting}
template <>
struct is_metaobject<Metaobject>
 : true_type
{ };
\end{lstlisting}

A template struct \verb@category@ should be defined and should return one of the
\hyperref[metaobject-category-tags]{metaobject category tags}, depending on
the actual kind of the metaobject.

\begin{lstlisting}
template <typename T>
struct category;

template <>
struct category<Metaobject>
 : MetaobjectCategory
{ };
\end{lstlisting}

\subsection{MetaSpecifier}
\label{concept-MetaSpecifier}

{\em MetaSpecifier} is a \meta{object} reflecting a C++ specifier. In addition to the requirements
inherited from \meta{object}, types conforming to this concept must satisfy the following:

The \verb@category@ template should return \verb@specifier_tag@ for all {\em MetaSpecifiers}.

\begin{lstlisting}
template <>
struct category<MetaSpecifier>
 : specifier_tag
{ };
\end{lstlisting}

