\subsection{MetaNamed}
\label{concept-MetaNamed}

\begin{tikzpicture}
\node[concept] (Metaobject) {Metaobject};
\node[concept] (MetaNamed) [right=of Metaobject] {MetaNamed}
	edge[inheritance] (Metaobject);
\end{tikzpicture}

\meta{Named} is a \meta{object} reflecting program constructs, which have a name
(are identified by an identifier) like namespaces, types, functions, variables, parameters, etc.

In addition to the requirements inherited from \meta{object}, the following requirements must
be satisfied:

The \verb@has_name@ template class specialization for a \meta{Named} should
inherit from \verb@true_type@:

\begin{lstlisting}
template <>
struct has_name<MetaNamed>
 : true_type
{ };
\end{lstlisting}

\subsubsection{\texttt{base\_name}}

A template class \verb@base_name@ should be defined an should return the base name
of the reflected construct, without the nested name specifier as a
\concept{StringConstant}:

\begin{lstlisting}
template <typename T>
struct base_name;

template <>
struct base_name<MetaNamed>
 : StringConstant
{ };
\end{lstlisting}

For example, if \verb@__meta_std_size_t@ reflects the \verb@std::size_t@ type,
then the matching specialization of \verb@base_name@ could be implmented in the following
way:

\begin{lstlisting}
template <>
struct base_name<__meta_std_size_t>
 : string_constant<'s','i','z','e','_','t'>
{ };
\end{lstlisting}

where the \verb@string_constant<'s','i','z','e','_','t'>@ class is a model
of \concept{StringConstant} as described above.

For namespace \verb@std@ the value should be \verb@"std"@, for namespace
\verb@foo::bar::baz@ it should be \verb@"baz"@, for the global scope the
value should be an empty string.

For \verb@std::vector<int>::iterator@ it should be \verb@"iterator"@. For derived,
qualified types like \verb@volatile std::vector<const foo::bar::fubar*> * const *@
it should be \verb@"volatile vector<const fubar*> * const *"@, etc.


\subsubsection{\texttt{named\_typedef}}

A template class \verb@named_typedef@ should be defined:

\begin{lstlisting}
template <typename X, typename T>
struct named_typedef;

template <typename X>
struct named_typedef<X, MetaNamedScoped>
{
	typedef X <NAME>;
};
\end{lstlisting}

The \verb@<NAME>@ expression above should be replaced in the actual specialization generated by the compiler
by the name of the reflected named object. For example if a type \verb@__meta_std_thread@
reflects the \verb@std::thread@ class, then the specialization of \verb@named_typedef@
for this metaobject should be following:

\begin{lstlisting}
template <typename X>
struct named_typedef<X, __meta_std_thread>
{
	typedef X thread;
};
\end{lstlisting}

if a type \verb@__meta_std@ reflects the \verb@std@ namespace, then the specialization of \verb@named_typedef@
should be:

\begin{lstlisting}
template <typename X>
struct named_typedef<X, __meta_std>
{
	typedef X std;
};
\end{lstlisting}

if types \verb@__meta_int@ and \verb@_meta_long_long_unsigned_int@ reflect the \verb@int@ and \verb@long long unsigned int@
types respectively, then the matching instantiations of \verb@named_typedef@ should be:
should be:

\begin{lstlisting}
template <typename X>
struct named_typedef<X, __meta_int>
{
	// note the trailing underscore
	typedef X int_;
};

template <typename X>
struct named_typedef<X, __meta_long_long_unsigned_int>
{
	// note underscores replacing the spaces
	typedef X long_long_unsigned_int;
};
\end{lstlisting}

\subsubsection{\texttt{named\_mem\_var}}

A template class \verb@named_mem_var@ should be defined as follows:

\begin{lstlisting}
template <typename X, typename T>
struct named_mem_var;

template <typename X>
struct named_mem_var<X, MetaNamedScoped>
{
	X <NAME>;

	template <typename ... P>
	named_mem_var(P&& p)
	 : <NAME>(std::forward<P>(p)...)
	{ };
};
\end{lstlisting}

The \verb@<NAME>@ expression above should be replaced in the actual specialization generated by the compiler
by the name of the reflected named object. For example if a type \verb@__meta_std_string@
reflects the \verb@std::string@ typedef, then the specialization of \verb@named_mem_var@
for this metaobject should be following:

\begin{lstlisting}
template <typename X>
struct named_mem_var<X, __meta_std_string>
{
	X string;

	template <typename ... P>
	named_mem_var(P&& ... p)
	 : string(std::forward<P>(p)...)
	{ }
};
\end{lstlisting}

if types \verb@__meta_void@ and \verb@_meta_long_double@ reflect the \verb@void@ and \verb@long double@
types respectively, then the matching instantiations of \verb@named_mem_var@ should be:
should be:

\begin{lstlisting}
template <typename X>
struct named_mem_var<X, __meta_void>
{
	// note the trailing underscore
	X void_;

	template <typename ... P>
	named_mem_var(P&& ... p)
	 : void_(std::forward<P>(p)...)
	{ }
};

template <typename X>
struct named_mem_var<X, __meta_long_double>
{
	// note underscores replacing the spaces
	typedef X long_double;

	template <typename ... P>
	named_mem_var(P&& ... p)
	 : long_double_(std::forward<P>(p)...)
	{ }
};
\end{lstlisting}

