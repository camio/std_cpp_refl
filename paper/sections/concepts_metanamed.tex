\subsection{MetaNamed}
\label{concept-MetaNamed}

{\em MetaNamed} is a \meta{object} reflecting program constructs, which have a name
(are identified by an identifier) like namespaces, types, functions, variables, parameters, etc.

In addition to the requirements inherited from \meta{object}, the following requirements must
be satisfied:

The \verb@has_name@ template class specialization for a {\em MetaNamed} should
inherit from \verb@true_type@:

\begin{lstlisting}
template <>
struct has_name<MetaNamed>
 : true_type
{ };
\end{lstlisting}

A template class \verb@base_name@ should be defined an should return the base name
of the reflected construct, without the nested name specifier as a
\hyperref[concept-StringConstant]{\em StringConstant}:

\begin{lstlisting}
template <typename T>
struct base_name;

template <>
struct base_name<MetaNamed>
 : StringConstant
{ };
\end{lstlisting}

For namespace \verb@std@ the value should be \verb@"std"@, for namespace
\verb@foo::bar::baz@ it should be \verb@"baz"@, for the global scope the
value should be an empty string.

For \verb@std::vector<int>::iterator@ it should be \verb@"iterator"@. For derived,
qualified types like \verb@volatile std::vector<const foo::bar::fubar*> * const *@
it should be \verb@"volatile vector<const fubar*> * const *"@, etc.

