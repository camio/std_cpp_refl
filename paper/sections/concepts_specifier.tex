\subsection{MetaSpecifier}
\label{concept-MetaSpecifier}

\begin{tikzpicture}
\node[concept] (Metaobject) {Metaobject};
\node[concept] (MetaSpecifier) [right=of Metaobject] {MetaSpecifier}
	edge[inheritance] (Metaobject);
\end{tikzpicture}

\meta{Specifier} is a \meta{object} reflecting a C++ specifier. In addition to the requirements
inherited from \meta{object}, types conforming to this concept must satisfy the following:

The \verb@metaobject_category@ template should return \verb@specifier_tag@ for all \meta{Specifiers}.

\begin{lstlisting}
template <>
struct metaobject_category<MetaSpecifier>
 : specifier_tag
{ };
\end{lstlisting}

\subsubsection{\texttt{specifier\_category}}

A template struct \verb@specifier_category@ should be defined and should inherit from one of the
\hyperref[specifier-category-tags]{specifier category tags}, depending on
the actual reflected specifier.

\begin{lstlisting}
template <typename T>
struct specifier_category;

template <>
struct specifier_category<MetaSpecifier>
 : SpecifierCategory
{ };
\end{lstlisting}

For example if the \verb@__meta_static@ metaobject reflects the \verb@static@
C++ specifier, then the specialization of \verb@specifier_category@
should be:

\begin{lstlisting}
template <>
struct specifier_category<__meta_static>
 : static_tag
{ };
\end{lstlisting}


\subsubsection{\texttt{keyword}}

A template struct \verb@keyword@ should be defined and should return
the keyword matching the reflected specifier as a
\concept{StringConstant}.

\begin{lstlisting}
template <typename T>
struct keyword;

template <>
struct keyword_category<MetaSpecifier>
 : StringConstant
{ };
\end{lstlisting}

For example if the \verb@__meta_thread_local@ metaobject reflects the \verb@thread local@
specifier, then the matching specialization of \verb@keyword@ could be following:

\begin{lstlisting}
template <>
struct keyword<__meta_thread_local>
 : string_constant<'t','h','r','e','a','d',' ','l','o','c','a','l'>
{ };
\end{lstlisting}

The \verb@string_constant<'t','h','r','e','a','d',' ','l','o','c','a','l'>@
class should be a model of \concept{StringConstant} as described above.

