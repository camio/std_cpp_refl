<?xml version="1.0"?>
<!--
Autmatically generated file. Do not modify manually all changes will be lost.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8"/>
	<style>
body {
	color: black;
	background-color: white; 
	font-family: "Book Antiqua", "Times New Roman", "Times", serif;
	padding: 2em;
}

table {
	border: 2px solid black;
	border-collapse: collapse;
}

th {
	border: 2px solid black;
}

td {
	border: 1px solid black;
}

th, td {
	padding-left: 0.5em;
	padding-right: 0.5em;
}

table.header {
	border: none;
}

table.references {
	border: none;
}

table.header th,
table.header td {
	border: none;
}

table.references th,
table.references td {
	border: none;
}

table.header th {
	text-align: right;
	padding-right: 1em;
	vertical-align: top;
}

table.references th {
	text-align: right;
	padding-right: 1em;
}

table.references td {
	font-style: oblique;
}

table.references td a {
	color: black;
	text-decoration: none;
}

table.references td a:hover {
	color: black;
	text-decoration: underline;
}

blockquote.std {
	color: black;
	background-color: #F1F1F1;
	border: 1px solid #D1D1D1;
	padding-left: 0.5em;
	padding-right: 0.5em;
}

span.section_name {
	float: right;
	font-weight: bold;
}
pre {
	font-family: "Book Antiqua", "Times New Roman", "Times", serif;
	line-height: 1.1em;
}
pre code {
	font-family: "Hack", "OCR A Extended", "Consolas", "Lucida Console", monospace;
	line-height: 1.1em;
	font-size: small;
	-moz-tab-size: 2;
	-o-tab-size: 16;
	tab-size: 2;
}

pre {
	background-color: #F0F0F0;
}

object.htmlc {
	width: 100%;
	height: auto;
}
</style>
	<title>P0194R1 — Static reflection</title>
</head>
<body>

<table class="header">
	<tr><th>Document Number:</th><td><b>P0194R1</b>, ISO/IEC JTC1 SC22 WG21</td></tr>
  <tr><th>Date:</th><td>2016-05-17</td></tr>
  <tr><th>Project:</th><td>Programming Language C++</td></tr>
  <tr><th>Audience:</th><td>Reflection(SG7) / EWG</td></tr>
  <tr>
		<th rowspan="2">Authors:</th>
		<td>Matúš Chochlík (<a href="mailto:chochlik@gmail.com">chochlik@gmail.com</a>)</td>
	</tr>
  <tr>
		<td>Axel Naumann (axel.naumann@cern.ch)</td>
	</tr>
</table>

<h1>Static reflection</h1>


<h2>Table of Contents</h2>
<div id="TOC">
	<ul>
		<li><a href="#introduction">Introduction</a>
		</li>
		<li><a href="#revisions">Revision history</a>
		</li>
		<li><a href="#wording">Proposed wording</a>
		</li>
		<li><a href="#acks">Acknowledgments</a>
		</li>
	</ul>
</div>

<h2 id="introduction">Introduction</h2>

<p>TODO
</p>

<h2 id="revisions">Revision history</h2>

<h4>Revision 1 (<a href="#ref-N3996">N3996</a>)</h4>

<p>Describes the method of static reflection
by the means of compiler-generated anonymous types. Introduces the first version
of the metaobject concepts and some possiblities of their implementation.
Also includes discussion about the motivation and the design rationale for the proposal.
</p>

<h4>Revision 2 (<a href="#ref-N4111">N4111</a>)</h4>

<p>Refines the metaobject concepts and introduces
a concrete implementation of their interface by the means of templates similar
to the standard type traits. Describes some additions to the standard library
(mostly meta-programming utilities), which simpilfy the use of the metaobjects.
Answers some questions from the discussion about N3996 and expands the design
rationale.
</p>

<h4>Revision 3 (<a href="#ref-N4451">N4451</a>)</h4>

<p>Incorporates the feedback from the discussion
about N4111 at the Urbana meeting, most notably reduces the set of metaobject concepts and refines their
definitions, removes some of the additions to the standard library added in the previous revisions.
Adds context-dependent reflection.
</p>

<h4>Revision 4 (<a href="#ref-P0194R0">P0194R0</a>)</h4>

<p>Further refines the concepts from N4111; prefixes
the names of the metaobject operations with <code>get_</code>, adds new operations,
replaces the metaobject category tags with new metaobject traits.
Introduces a nested namespace <code>std::meta</code> which contains most
of the reflection-related additions to the standard library.
Rephrases definition of meta objects using Concepts Lite. Specifies the
reflection operator name — <code>reflexpr</code>.
Introduces an experimental implementation of the reflection operator in clang.
Drops the context-dependent reflection from N4111 (will be re-introduced later).
</p>

<h4>Revision 5 (P0194R1)</h4>

Dropped all metaobject traits except <code>is_metaobject</code>. All metaobject
classification is now done by using the concepts.

<h2 id="wording">Proposed wording</h2>

<p>Insert a new element in Table 1, <em>C++ library headers</em> of
[general.namespaces], named <code>&lt;experimental/reflexpr&gt;</code>.
</p>

<p>Insert a new section:
</p>

<blockquote class="std">
	<h3>? Compile-time reflection <span class="section_name">[refl]</span></h3>

	<h4>?.1 General description <span class="section_name">[refl.general]</span></h4>

	<p>Compile-time constant metadata describing various aspects of a compiled program
	are provided indirectly by the means of types generated by the compiler —
	<em>metaobjects</em>.

	A <em>Metaobject</em> is an anonymous type <em>reflecting</em>
	(representing) a particular declaration in a C++ program. It can be
	reasoned-about at compile-time and provides access to <em>metadata</em>
	describing various properties of the reflected declaration through
	a set of templates.

	The <em>metaobject</em> types themselves are opaque, without any visible
	internal structure and they cannot be instantiated.
	</p>

	<p>The metaobjects shall be generated on demand by the compiler as
	the result of the invocation of the <code>reflexpr</code> operator.
	</p>
	
	<p>The actual metadata can be obtained by instantiating templates constituting
	the <em>interface</em> of the metaobjects. Each template serves a particular
	purpose and provides a single piece of metadata. These templates are
	collectively referred to as <em>metaobject operations</em>.
	</p>

	<p>Metaobjects reflecting different kinds of declarations conform to different
	<em>metaobject concepts</em> and have different interfaces — sets of templates
	applicable on the metaobjects. These concepts can also be used for
	metaobject classification.

	</p><p>Metaobject concepts form a generalization-specialization hierarchy, with
	<code>meta::Object</code> being the common generalization for all metaobjects.
	</p>

	<h4>?.2 Metaobject trait<span class="section_name">[refl.trait]</span></h4>

	<p>A new <em>UnaryTypeTrait</em> — <code>is_metaobject</code> shall be added
	to section [meta.unary.cat] to distinguish between metaobject types generated
	by the compiler and all other types.
	</p>

<pre><code>
namespace std {
namespace experimental {

template &lt;typename T&gt; struct is_metaobject;

} // namespace experimental
} // namespace std
</code></pre>

<pre>
[Example:
<code>
is_metaobject_v&lt;int&gt;;                   // false
is_metaobject_v&lt;void&gt;;                  // false
is_metaobject_v&lt;string&gt;;                // false
is_metaobject_v&lt;reflexpr(int)&gt;;         // true
is_metaobject_v&lt;reflexpr(std)&gt;;         // true
is_metaobject_v&lt;reflexpr(std::string)&gt;; // true
</code>
— end example]
</pre>

	<h4>?.3 Header <code>&lt;experimental/reflexpr&gt;</code> synopsis<span class="section_name">[refl.synopsis]</span></h4>

	<pre><code>
namespace std {
namespace experimental
namespace meta {

// <em>metaobject concepts</em>
template &lt;typename T&gt; concept bool Object;
template &lt;Object T&gt; concept bool ObjectSequence;
template &lt;Object T&gt; concept bool Revertible;
template &lt;Object T&gt; concept bool Named;
template &lt;Object T&gt; concept bool Specifier;
template &lt;Object T&gt; concept bool Typed;
template &lt;Object T&gt; concept bool ScopeMember;
template &lt;Object T&gt; concept bool Scope;
template &lt;Object T&gt; concept bool Alias;
template &lt;Object T&gt; concept bool ClassMember;
template &lt;Object T&gt; concept bool Linkable;
template &lt;Object T&gt; concept bool Namespace;
template &lt;Object T&gt; concept bool GlobalScope;
template &lt;Object T&gt; concept bool NamespaceAlias;
template &lt;Object T&gt; concept bool Type;
template &lt;Object T&gt; concept bool TypeAlias;
template &lt;Object T&gt; concept bool Class;
template &lt;Object T&gt; concept bool Enum;
template &lt;Object T&gt; concept bool EnumClass;
template &lt;Object T&gt; concept bool Constant;
template &lt;Object T&gt; concept bool Variable;
template &lt;Object T&gt; concept bool DataMember;
template &lt;Object T&gt; concept bool MemberType;
template &lt;Object T&gt; concept bool EnumValue;


// <em>metaobject operations</em>
template &lt;Object T1, Object T2&gt; struct reflects_same;
template &lt;Object T&gt; struct get_source_location;
template &lt;ObjectSequence T&gt; struct get_size;
template &lt;ObjectSequence T1, size_t Index&gt; struct get_element;
template &lt;Named T&gt; struct get_name;
template &lt;Typed T&gt; struct get_type;
template &lt;ScopeMember T&gt; struct get_scope;
template &lt;Alias T&gt; struct get_aliased;
template &lt;ClassMember T&gt; struct is_public;
template &lt;ClassMember T&gt; struct get_access_specifier;
template &lt;Linkable T&gt; struct is_static;
template &lt;Type T&gt; struct get_reflected_type;
template &lt;Class T&gt; struct get_data_members;
template &lt;Class T&gt; struct get_all_data_members;
template &lt;Class T&gt; struct get_member_types;
template &lt;Class T&gt; struct get_all_member_types;
template &lt;Constant T&gt; struct get_constant;
template &lt;Variable T&gt; struct get_pointer;


// 
template &lt;Object T1, Object T2&gt;
  constexpr auto reflects_same_v = reflects_same&lt;T1, T2&gt;::value;
template &lt;ObjectSequence T&gt;
  constexpr auto get_size_v = get_size&lt;T&gt;::value;
template &lt;ObjectSequence T1, size_t Index&gt;
  using get_element_t = typename get_element&lt;T1, Index&gt;::type;
template &lt;Named T&gt;
  constexpr auto get_name_v = get_name&lt;T&gt;::value;
template &lt;Typed T&gt;
  using get_type_t = typename get_type&lt;T&gt;::type;
template &lt;ScopeMember T&gt;
  using get_scope_t = typename get_scope&lt;T&gt;::type;
template &lt;Alias T&gt;
  using get_aliased_t = typename get_aliased&lt;T&gt;::type;
template &lt;ClassMember T&gt;
  constexpr auto is_public_v = is_public&lt;T&gt;::value;
template &lt;ClassMember T&gt;
  using get_access_specifier_t = typename get_access_specifier&lt;T&gt;::type;
template &lt;Linkable T&gt;
  constexpr auto is_static_v = is_static&lt;T&gt;::value;
template &lt;Type T&gt;
  constexpr auto get_reflected_type_v = get_reflected_type&lt;T&gt;::value;
template &lt;Class T&gt;
  using get_data_members_t = typename get_data_members&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_all_data_members_t = typename get_all_data_members&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_member_types_t = typename get_member_types&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_all_member_types_t = typename get_all_member_types&lt;T&gt;::type;
template &lt;Constant T&gt;
  constexpr auto get_constant_v = get_constant&lt;T&gt;::value;
template &lt;Variable T&gt;
  const auto get_pointer_v = get_pointer&lt;T&gt;::value;


} // namespace meta
} // namespace experimental
} // namespace std
</code></pre>


	<h4>?.4 Metaobject concepts<span class="section_name">[refl.concepts]</span></h4>

	<div><table>
<tr>
<th>Concept</th>
<th>Requirements</th>
<th>Optional restrictions</th>
<th>Description</th>
</tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Object;
</code></pre></td><td><code>is_metaobject_v&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Object</code> is a concept modelled by stateless anonymous types generated by the compiler which allow access to metadata reflecting specific program declarations.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool ObjectSequence;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td/><td><p><code>meta::ObjectSequence</code> is an ordered sequence of metaobjects..
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Revertible;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Revertible</code> reflects a revertible declaration.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Named;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Named</code> reflects a named declaration.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Specifier;
</code></pre></td><td><code>Named&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Specifier</code> reflects a specifier (const, virtual, static, noexcept, public, etc.).
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Typed;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Typed</code> reflects base-level declaration with a type.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool ScopeMember;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td/><td><p><code>meta::ScopeMember</code> reflects a scoped declaration.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Scope;
</code></pre></td><td><code>Object&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Scope</code> reflects a scope.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Alias;
</code></pre></td><td><code>Named&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Alias</code> reflects a type or namespace alias.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool ClassMember;
</code></pre></td><td><code>ScopeMember&lt;T&gt;</code><br/><code>Class&lt;get_scope_t&lt;T&gt;&gt;</code><br/></td><td/><td><p><code>meta::ClassMember</code> reflects class member.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Linkable;
</code></pre></td><td><code>Named&lt;T&gt;</code><br/><code>ScopeMember&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Linkable</code> reflects declaration with storage duration and/or linkage.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Namespace;
</code></pre></td><td><code>Scope&lt;T&gt;</code><br/></td><td><code>Named&lt;T&gt;</code><br/><code>ScopeMember&lt;T&gt;</code><br/></td><td><p><code>meta::Namespace</code> reflects a namespace.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool GlobalScope;
</code></pre></td><td><code>Namespace&lt;T&gt;</code><br/><code>not(Named&lt;T&gt;)</code><br/><code>not(ScopeMember&lt;T&gt;)</code><br/></td><td/><td><p><code>meta::GlobalScope</code> reflects the global scope.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool NamespaceAlias;
</code></pre></td><td><code>Namespace&lt;T&gt;</code><br/><code>Alias&lt;T&gt;</code><br/><code>Namespace&lt;get_aliased_t&lt;T&gt;&gt;</code><br/></td><td/><td><p><code>meta::NamespaceAlias</code> reflects a namespace alias.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Type;
</code></pre></td><td><code>ScopeMember&lt;T&gt;</code><br/></td><td><code>Named&lt;T&gt;</code><br/></td><td><p><code>meta::Type</code> reflects a type.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool TypeAlias;
</code></pre></td><td><code>Type&lt;T&gt;</code><br/><code>Alias&lt;T&gt;</code><br/><code>Type&lt;get_aliased_t&lt;T&gt;&gt;</code><br/></td><td/><td><p><code>meta::TypeAlias</code> reflects a type alias or typedef.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Class;
</code></pre></td><td><code>Type&lt;T&gt;</code><br/><code>Scope&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Class</code> reflects a class.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Enum;
</code></pre></td><td><code>Type&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Enum</code> reflects an enumeration.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool EnumClass;
</code></pre></td><td><code>Enum&lt;T&gt;</code><br/><code>Scope&lt;T&gt;</code><br/></td><td/><td><p><code>meta::EnumClass</code> reflects a strongly typed enumeration.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Constant;
</code></pre></td><td><code>Named&lt;T&gt;</code><br/><code>Typed&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Constant</code> reflects a compile-time constant value.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool Variable;
</code></pre></td><td><code>Named&lt;T&gt;</code><br/><code>Typed&lt;T&gt;</code><br/><code>Linkable&lt;T&gt;</code><br/></td><td/><td><p><code>meta::Variable</code> reflects a variable.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool DataMember;
</code></pre></td><td><code>Variable&lt;T&gt;</code><br/><code>ClassMember&lt;T&gt;</code><br/></td><td/><td><p><code>meta::DataMember</code> reflects a class data member.
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool MemberType;
</code></pre></td><td><code>Type&lt;T&gt;</code><br/><code>ClassMember&lt;T&gt;</code><br/></td><td/><td><p><code>meta::MemberType</code> reflects a class member type (typedef, class, union, enum).
		</p></td></tr>


<tr><td>
<pre><code>
template &lt;typename T&gt;
concept bool EnumValue;
</code></pre></td><td><code>Constant&lt;T&gt;</code><br/><code>ScopeMember&lt;T&gt;</code><br/><code>Enum&lt;get_type_t&lt;T&gt;&gt;</code><br/></td><td/><td><p><code>meta::EnumValue</code> reflects an enum value.
		</p></td></tr>
</table></div>

	<p>[Note: Metaobjects reflecting anonymous types, anonymous namespaces
	or the global scope do not satisfy the <code>meta::Named</code> concept.
	This means that they do not implement the <code>meta::get_name</code> operation.
	— end note]
	</p>

	<p>[Note: Metaobjects reflecting the global scope do not satisfy the
	<code>meta::ScopeMember</code> concept.
	This means that they do not implement the <code>meta::get_scope</code> operation.
	— end note]
	</p>

	<p>[Note: Metaobjects reflecting strongly-typed enumerations conform
	to the <code>meta::Scope</code> concept, regular enumerations do not.
	— end note]
	</p>


<pre>
[Example:
<code>
TODO
</code>
— end example]
</pre>

	<h4>?.5 Metaobject operations<span class="section_name">[refl.ops]</span></h4>

	A <em>MetaobjectOperation</em> returns a single piece of metadata describing
	a particular aspect of the declaration reflected by a <em>Metaobject</em>.
	It shall be a class template taking one or more arguments at least one
	of which is a model of the <em>Metaobject</em> concept.
	The result of a <em>MetaobjectOperation</em> can be either a compile-time
	constant value a <code>const</code> pointer or a type.

	<h5>?.5.1 Boolean constant result<span class="section_name">[refl.ops.bool]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning a boolean value,
	shall publicly and unambiguously derive from <code>true_type</code> or
	<code>false_type</code>.
	</p>

	<h5>?.5.2 Integral constant result<span class="section_name">[refl.ops.int]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning an integer or
	<code>enum</code> value, shall publicly and unambiguously derive from
	a specialization of <code>integral_constant</code> with apropriate
	integer or <code>enum</code> type as the first argument.
	</p>

	<h5>?.5.3 String constant result<span class="section_name">[refl.ops.str]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning a character string,
	shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef const char value_type[N+1];
	static constexpr const char value[N+1];
};
</code></pre>

	<p>where <code>N</code> is the length of the returned string and the
	last element in the <code>value</code> character array, shall be the
	<code>'\0'</code> character.
	The member names <code>value_type</code>, <code>value</code>,
	<code>type</code>, shall be publicly and unambiguously available
	in such <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.4 Metaobject result<span class="section_name">[refl.ops.metaobj]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates yielding another metaobject,
	shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef meta::<em>Object</em> type;
};
</code></pre>

	<p>The member name <code>type</code>, shall be publicly and unambiguously
	available in such <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.5 Type result<span class="section_name">[refl.ops.type]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates yielding a non-metaobject
	type, shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef <em>unspecified</em> type;
};
</code></pre>

	<p>The member name <code>type</code>, shall be publicly and unambiguously
	available in a <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.6 Pointer result<span class="section_name">[refl.ops.ptr]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates returning a pointer or
	a class data member pointer, shall instantiate into a type
	<em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef conditional_t&lt;
		bool(<em>is-non-static-class-data-member</em>),
		<em>unspecified-type</em> <em>unspecified-class</em>::*,
		<em>unspecified-type</em>*
	&gt; value_type;

	static const value_type value;
};
</code></pre>

	<h5>?.5.7 Operation description<span class="section_name">[refl.ops.desc]</span></h5>

	<div><table><tr><th>Template</th>
<th>Description</th>
<th>Result</th></tr>
<tr><td><pre><code>template &lt;Object T1, Object T2&gt;
struct reflects_same;
</code></pre></td><td>indicates if two metaobjects reflect the same base-level declaration.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Object T&gt;
struct get_source_location;
</code></pre></td><td>returns the source location info of the declaration of a base-level program declaration reflected by a <code>meta::<em>Object</em></code>.</td><td>
		a <code>std::source_location</code> constant
	</td></tr><tr><td><pre><code>template &lt;ObjectSequence T&gt;
struct get_size;
</code></pre></td><td>returns a number of elements in the sequence.</td><td>
		a <code>size_t</code> integral constant
	</td></tr><tr><td><pre><code>template &lt;ObjectSequence T1, size_t Index&gt;
struct get_element;
</code></pre></td><td>returns the i-th <code>meta::<em>Object</em></code> in a <code>meta::<em>ObjectSequence</em></code>.</td><td>
		<code>meta::<em>Object</em></code>
	</td></tr><tr><td><pre><code>template &lt;Named T&gt;
struct get_name;
</code></pre></td><td>returns the basic name of the a named declaration reflected by a <code>meta::<em>Named</em></code>.</td><td>a string constant</td></tr><tr><td><pre><code>template &lt;Typed T&gt;
struct get_type;
</code></pre></td><td>returns the <code>meta::<em>Type</em></code> reflecting the type of base-level declaration with a type reflected by a <code>meta::<em>Typed</em></code>.</td><td>
		<code>meta::<em>Type</em></code>
	</td></tr><tr><td><pre><code>template &lt;ScopeMember T&gt;
struct get_scope;
</code></pre></td><td>returns the <code>meta::<em>Scope</em></code> reflecting the scope of a scoped declaration reflected by a <code>meta::<em>ScopeMember</em></code>.</td><td>
		<code>meta::<em>Scope</em></code>
	</td></tr><tr><td><pre><code>template &lt;Alias T&gt;
struct get_aliased;
</code></pre></td><td>returns the <code>meta::<em>Named</em></code> reflecting the original declaration of a type or namespace alias reflected by a <code>meta::<em>Alias</em></code>.</td><td>
		<code>meta::<em>Named</em></code>
	</td></tr><tr><td><pre><code>template &lt;ClassMember T&gt;
struct is_public;
</code></pre></td><td>returns whether the class member reflected by a <code>meta::<em>ClassMember</em></code> was declared with public access.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;ClassMember T&gt;
struct get_access_specifier;
</code></pre></td><td>returns the <code>meta::<em>Specifier</em></code> reflecting the access specifier of class member reflected by a <code>meta::<em>ClassMember</em></code>.</td><td>
		<code>meta::<em>Specifier</em></code>
	</td></tr><tr><td><pre><code>template &lt;Linkable T&gt;
struct is_static;
</code></pre></td><td>returns whether the declaration with storage duration and/or linkage reflected by a <code>meta::<em>Linkable</em></code> was declared with the static specifier.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Type T&gt;
struct get_reflected_type;
</code></pre></td><td>returns the the base-level type reflected by a <code>meta::<em>Type</em></code>.</td><td>the original type reflected by the argument</td></tr><tr><td><pre><code>template &lt;Class T&gt;
struct get_data_members;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of elements reflecting   the public data members of a class reflected by a <code>meta::<em>Class</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
	</td></tr><tr><td><pre><code>template &lt;Class T&gt;
struct get_all_data_members;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of elements reflecting all   (including the private and protected)   data members of a class reflected by a <code>meta::<em>Class</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
	</td></tr><tr><td><pre><code>template &lt;Class T&gt;
struct get_member_types;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of elements reflecting   the public member types of a class reflected by a <code>meta::<em>Class</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
	</td></tr><tr><td><pre><code>template &lt;Class T&gt;
struct get_all_member_types;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of elements reflecting all   (including the private and protected)   member types of a class reflected by a <code>meta::<em>Class</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
	</td></tr><tr><td><pre><code>template &lt;Constant T&gt;
struct get_constant;
</code></pre></td><td>returns the value of a compile-time constant value reflected by a <code>meta::<em>Constant</em></code>.</td><td>
		a constant value of an unspecified, integer or enum type
	</td></tr><tr><td><pre><code>template &lt;Variable T&gt;
struct get_pointer;
</code></pre></td><td>returns a pointer to the a variable reflected by a <code>meta::<em>Variable</em></code>.   If the variable is a class member then the pointer is a class data member pointer,   otherwise it is a plain pointer.</td><td>a regular or class data member pointer</td></tr></table></div>

	<p>The <code>get_name</code> operation returns the type, alias, namespace, etc.
	name without any qualifiers, asterisks, ampersands, angle or square brackets, etc.
	</p>

<pre>
[Example:
<code>
using foo = int;
using bar = foo;
namespace std = baz;

meta::get_name_v&lt;reflexpr(int)&gt;;    // "int"
meta::get_name_v&lt;reflexpr(std)&gt;;    // "std"
meta::get_name_v&lt;reflexpr(foo)&gt;;    // "foo"
meta::get_name_v&lt;reflexpr(bar)&gt;;    // "bar"
meta::get_name_v&lt;reflexpr(baz)&gt;;    // "baz"
</code>
— end example]
</pre>

<pre>
[Example:
<code>
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;)&gt;;                                // "vector"
meta::get_name_v&lt;reflexpr(const std::pair)&gt;;                                 // "pair"
meta::get_name_v&lt;reflexpr(volatile std::size_t* [10])&gt;;                      // "size_t"
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;* (*)(std::vector&lt;double&gt;&amp;))&gt;;     // ""
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;* (*pfoo)(std::vector&lt;double&gt;&amp;))&gt;; // "pfoo"
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;* foo(std::vector&lt;double&gt;&amp;))&gt;;     // "foo"
meta::get_name_v&lt;reflexpr(std::chrono)&gt;;                                     // "chrono"
meta::get_name_v&lt;reflexpr(std::nothrow)&gt;;                                    // "nothrow"
meta::get_name_v&lt;reflexpr(std::string::npos)&gt;;                               // "npos"
</code>
— end example]
</pre>

<pre>
[Example:
<code>
auto l = [](void) { };
meta::get_name_v&lt;reflexpr(::)&gt;;           // "error"
meta::get_name_v&lt;reflexpr(decltype(l))&gt;;  // "error"
</code>
— end example]
</pre>

	<h4>?.6 The reflection operator<span class="section_name">[refl.reflexpr]</span></h4>

	<p>TODO
	</p>

	<h5>?.6.1 Redeclarations<span class="section_name">[refl.reflexpr.redecl]</span></h5>

	<p>The meta data queried by <code>reflexpr</code> depends on the point of invocation
	of the operator; only declarations in front of the invocation will be visible.
	Subsequent invocations are independent of prior invocations, as if all compiler
	generated types were unique to each <code>reflexpr</code> invocation.
	</p>

<pre>
[Example:
<code>
struct foo;
using meta_foo_fwd1 = reflexpr(foo);
constexpr size_t n1 = get_size_v&lt;get_data_members_t&lt;meta_foo_fwd1&gt;&gt;; // 0

struct foo;
using meta_foo_fwd2 = reflexpr(foo);
constexpr size_t n2 = get_size_v&lt;get_data_members_t&lt;meta_foo_fwd2&gt;&gt;; // 0

constexpr bool b1 = is_same_v&lt;meta_foo_fwd1, meta_foo_fwd2&gt;;             // <em>unspecified</em>
constexpr bool b2 = meta::reflects_same_v&lt;meta_foo_fwd1, meta_foo_fwd2&gt;; // true

struct foo { int a,b,c,d; };
using meta_foo = reflexpr(foo);
constexpr size_t n3 = get_size_v&lt;get_data_members_t&lt;meta_foo&gt;&gt;;      // 4

constexpr bool b3 = is_same_v&lt;meta_foo_fwd1, meta_foo&gt;;             // false
constexpr bool b4 = meta::reflects_same_v&lt;meta_foo_fwd1, meta_foo&gt;; // true
</code>
— end example]
</pre>

	<h5>?.6.2 Required header<span class="section_name">[refl.reflexpr.header]</span></h5>

	<p>If the header <code>&lt;reflexpr&gt;</code> is not included prior to a use
	of <code>reflexpr</code>, the program is ill-formed.
	This header file defines the templates implementing the operations
	on metaobjects as described above.
	</p>

	<h5>?.6.3 Reverse reflection<span class="section_name">[refl.reflexpr.rev]</span></h5>

</blockquote>

<h2 id="acks">Acknowledgments</h2>

<p>TODO
</p>

<h2>References</h2>

<table class="references">
<tr id="ref-P0194R0">
	<th>[P0194R0]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r0.pdf">
		Chochlík M., Naumann A. — P0194R0 - Static reflection (revision 4)
	</a>
  </td>
</tr>

<tr id="ref-N4451">
	<th>[N4451]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4451.pdf">
		Chochlík M. — N4451 - Static reflection (revision 3)
  </a>
  </td>
</tr>

<tr id="ref-N4111">
	<th>[N4111]</th>
	<td>
	<a href="https://isocpp.org/files/papers/n4111.pdf">
		Chochlík M. — N4111 - Static reflection (revision 2)
	</a>
  </td>
</tr>

<tr id="ref-N3996">
	<th>[N3996]</th>
	<td>
	<a href="https://isocpp.org/files/papers/n3996.pdf">
		Chochlík M. — N3996 - Static reflection
	</a>
  </td>
</tr>
</table>

</body>
</html>
