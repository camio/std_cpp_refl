<?xml version="1.0"?>
<!--
Autmatically generated file. Do not modify manually all changes will be lost.
-->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8"/>
	<style>
body {
	color: black;
	background-color: white; 
	font-family: "Book Antiqua", "Times New Roman", "Times", serif;
	padding: 2em;
}

table {
	border: 2px solid black;
	border-collapse: collapse;
}

th {
	border: 2px solid black;
}

td {
	border: 1px solid black;
}

th, td {
	padding-left: 0.5em;
	padding-right: 0.5em;
}

table.header {
	border: none;
}

table.references {
	border: none;
}

table.header th,
table.header td {
	border: none;
}

table.references th,
table.references td {
	border: none;
}

table.header th {
	text-align: right;
	padding-right: 1em;
	vertical-align: top;
}

table.references th {
	text-align: right;
	padding-right: 1em;
}

table.references td {
	font-style: oblique;
}

table.references td a {
	color: black;
	text-decoration: none;
}

table.references td a:hover {
	color: black;
	text-decoration: underline;
}

blockquote.std {
	color: black;
	background-color: #F1F1F1;
	border: 1px solid #D1D1D1;
	padding-left: 0.5em;
	padding-right: 0.5em;
}

span.section_name {
	float: right;
	font-weight: bold;
}
pre code {
	font-family: "Hack", "OCR A Extended", "Consolas", "Lucida Console", monospace;
	line-height: 1.1em;
	font-size: small;
	-moz-tab-size: 2;
	-o-tab-size: 16;
	tab-size: 2;
}

pre {
	background-color: #F0F0F0;
}

object.htmlc {
	width: 100%;
	height: auto;
}
</style>
	<title>P0194R1 -- Static reflection</title>
</head>
<body>

<table class="header">
	<tr><th>Document Number:</th><td><b>P0194R1</b>, ISO/IEC JTC1 SC22 WG21</td></tr>
  <tr><th>Date:</th><td>2016-05-17</td></tr>
  <tr><th>Project:</th><td>Programming Language C++</td></tr>
  <tr><th>Audience:</th><td>Reflection(SG7) / EWG</td></tr>
  <tr>
		<th rowspan="2">Authors:</th>
		<td>Matúš Chochlík (<a href="mailto:chochlik@gmail.com">chochlik@gmail.com</a>)</td>
	</tr>
  <tr>
		<td>Axel Naumann (axel.naumann@cern.ch)</td>
	</tr>
</table>

<h1>Static reflection</h1>


<h2>Table of Contents</h2>
<div id="TOC">
	<ul>
		<li><a href="#introduction">Introduction</a>
		</li>
		<li><a href="#revisions">Revision history</a>
		</li>
		<li><a href="#wording">Proposed wording</a>
		</li>
		<li><a href="#acks">Acknowledgments</a>
		</li>
	</ul>
</div>

<h2 id="introduction">Introduction</h2>

<p>TODO
</p>

<h2 id="revisions">Revision history</h2>

<p>TODO
</p>

<h2 id="wording">Proposed wording</h2>

<p>Insert a new element in Table 1, <em>C++ library headers</em> of
[general.namespaces], named <code>&lt;experimental/reflexpr&gt;</code>.
</p>

<p>Insert a new section:
</p>

<blockquote class="std">
	<h3>? Compile-time reflection <span class="section_name">[refl]</span></h3>

	<h4>?.1 General description <span class="section_name">[refl.general]</span></h4>

	<p>Compile-time constant metadata describing various aspects of a compiled program
	are provided indirectly by the means of types generated by the compiler --
	<em>metaobjects</em>.

	A <em>Metaobject</em> is an anonymous type <em>reflecting</em>
	(representing) a particular declaration in a C++ program. It can be
	reasoned-about at compile-time and provides access to <em>metadata</em>
	describing various properties of the reflected declaration through
	a set of templates.

	The <em>metaobject</em> types themselves are opaque, without any internal
	structure and they cannot be instantiated.
	</p>

	<p>The metaobjects shall be generated on demand by the compiler as
	the result of the invocation of the <code>reflexpr</code> operator.
	</p>
	
	<p>The actual metadata can be obtained by instantiating templates constituting
	the <em>interface</em> of the metaobjects. Each template serves a particular
	purpose and provides a single piece of metadata. These templates are
	collectively referred to as <em>metaobject operations</em>.
	</p>

	Metaobjects reflecting different kinds of declarations conform to different
	<em>metaobject concepts</em> and have different interfaces -- sets of templates
	applicable on the metaobjects. Another set of templates -- the <em>metaobject
	traits</em> can be used to determine which concepts a metaobject conforms to.

	Metaobject concepts form a generalization-specialization hierarchy, with
	<code>meta::Object</code> being the common generalization for all metaobjects.

	<p>A <em>MetaobjectTrait</em> describes a property of a metaobject type,
	typically it indicates if a metaobject conforms to a particular
	<em>metaobject concept</em>.
	
	It shall be a class template that takes one template type argument.
	It shall be <code>DefaultConstructible</code>, <code>CopyConstructible</code>
	and publicly and unambiguously derived, directly or indirectly from
	<code>true_type</code> or <code>false_type</code>.
	</p>

	<p>A new <em>UnaryTypeTrait</em> -- <code>is_metaobject</code> shall be added
	to section 20.11.2 to distinguish between metaobject types generated
	by the compiler and all other types.

</p><pre><code>
namespace std {
namespace experimental {

template &lt;typename T&gt; struct is_metaobject;

} // namespace experimental
} // namespace std
</code></pre>

	<h4>?.2 Header <code>&lt;experimental/reflexpr&gt;</code> synopsis<span class="section_name">[refl.synopsis]</span></h4>

	<pre><code>
namespace std {
namespace experimental
namespace meta {

// <em>metaobject concepts</em>
template &lt;typename T&gt; concept bool Object;
template &lt;Object T&gt; concept bool ObjectSequence;
template &lt;Object T&gt; concept bool Revertible;
template &lt;Object T&gt; concept bool Named;
template &lt;Object T&gt; concept bool Typed;
template &lt;Object T&gt; concept bool ScopeMember;
template &lt;Object T&gt; concept bool Scope;
template &lt;Object T&gt; concept bool Alias;
template &lt;Object T&gt; concept bool ClassMember;
template &lt;Object T&gt; concept bool Linkable;
template &lt;Object T&gt; concept bool GlobalScope;
template &lt;Object T&gt; concept bool Namespace;
template &lt;Object T&gt; concept bool NamespaceAlias;
template &lt;Object T&gt; concept bool Type;
template &lt;Object T&gt; concept bool TypeAlias;
template &lt;Object T&gt; concept bool Class;
template &lt;Object T&gt; concept bool Enum;
template &lt;Object T&gt; concept bool EnumClass;
template &lt;Object T&gt; concept bool Constant;
template &lt;Object T&gt; concept bool Variable;
template &lt;Object T&gt; concept bool DataMember;
template &lt;Object T&gt; concept bool MemberType;
template &lt;Object T&gt; concept bool EnumValue;


// <em>metaobject traits</em>
template &lt;Object T&gt; struct is_sequence;
template &lt;Object T&gt; struct is_revertible;
template &lt;Object T&gt; struct has_name;
template &lt;Object T&gt; struct has_type;
template &lt;Object T&gt; struct has_scope;
template &lt;Object T&gt; struct is_scope;
template &lt;Object T&gt; struct is_alias;
template &lt;Object T&gt; struct is_class_member;
template &lt;Object T&gt; struct is_linkable;
template &lt;Object T&gt; struct is_global_scope;
template &lt;Object T&gt; struct is_namespace;
template &lt;Object T&gt; struct is_type;
template &lt;Object T&gt; struct is_class;
template &lt;Object T&gt; struct is_enum;
template &lt;Object T&gt; struct is_constant;
template &lt;Object T&gt; struct is_variable;
template &lt;Object T&gt; struct is_enum_value;

// 
template &lt;Object T&gt;
  constexpr bool is_sequence_v = is_sequence&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_revertible_v = is_revertible&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool has_name_v = has_name&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool has_type_v = has_type&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool has_scope_v = has_scope&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_scope_v = is_scope&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_alias_v = is_alias&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_class_member_v = is_class_member&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_linkable_v = is_linkable&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_global_scope_v = is_global_scope&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_namespace_v = is_namespace&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_type_v = is_type&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_class_v = is_class&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_enum_v = is_enum&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_constant_v = is_constant&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_variable_v = is_variable&lt;T&gt;::value;
template &lt;Object T&gt;
  constexpr bool is_enum_value_v = is_enum_value&lt;T&gt;::value;


// <em>metaobject operations</em>
template &lt;Object T1, Object T2&gt; struct reflects_same;
template &lt;Object T&gt; struct get_source_location;
template &lt;ObjectSequence T&gt; struct get_size;
template &lt;ObjectSequence T1, size_t Index&gt; struct get_element;
template &lt;Named T&gt; struct get_name;
template &lt;Typed T&gt; struct get_type;
template &lt;ScopeMember T&gt; struct get_scope;
template &lt;Alias T&gt; struct get_aliased;
template &lt;ClassMember T&gt; struct is_public;
template &lt;Linkable T&gt; struct is_static;
template &lt;Type T&gt; struct get_reflected_type;
template &lt;Class T&gt; struct get_data_members;
template &lt;Class T&gt; struct get_all_data_members;
template &lt;Class T&gt; struct get_member_types;
template &lt;Class T&gt; struct get_all_member_types;
template &lt;Constant T&gt; struct get_constant;
template &lt;Variable T&gt; struct get_pointer;


// 
template &lt;Object T1, Object T2&gt;
  constexpr auto reflects_same_v = reflects_same&lt;T1, T2&gt;::value;
template &lt;ObjectSequence T&gt;
  constexpr auto get_size_v = get_size&lt;T&gt;::value;
template &lt;ObjectSequence T1, size_t Index&gt;
  using get_element_t = typename get_element&lt;T1, Index&gt;::type;
template &lt;Named T&gt;
  constexpr auto get_name_v = get_name&lt;T&gt;::value;
template &lt;Typed T&gt;
  using get_type_t = typename get_type&lt;T&gt;::type;
template &lt;ScopeMember T&gt;
  using get_scope_t = typename get_scope&lt;T&gt;::type;
template &lt;Alias T&gt;
  using get_aliased_t = typename get_aliased&lt;T&gt;::type;
template &lt;ClassMember T&gt;
  constexpr auto is_public_v = is_public&lt;T&gt;::value;
template &lt;Linkable T&gt;
  constexpr auto is_static_v = is_static&lt;T&gt;::value;
template &lt;Type T&gt;
  constexpr auto get_reflected_type_v = get_reflected_type&lt;T&gt;::value;
template &lt;Class T&gt;
  using get_data_members_t = typename get_data_members&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_all_data_members_t = typename get_all_data_members&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_member_types_t = typename get_member_types&lt;T&gt;::type;
template &lt;Class T&gt;
  using get_all_member_types_t = typename get_all_member_types&lt;T&gt;::type;
template &lt;Constant T&gt;
  constexpr auto get_constant_v = get_constant&lt;T&gt;::value;
template &lt;Variable T&gt;
  const auto get_pointer_v = get_pointer&lt;T&gt;::value;


} // namespace meta
} // namespace experimental
} // namespace std
</code></pre>

	<h4>?.3 Metaobject traits<span class="section_name">[refl.traits]</span></h4>

	<p>The <em>MetaobjectTrait</em> templates require their argument
	to be models of the <code>meta::Object</code> concept. The <code>is_metaobject</code>
	type trait can be used to distinguish valid metaobjects from other types.
	</p>
	<p>If a type <code>T</code> is a model of a particular metaobject concept
	as listed in the table below, then the matching trait template shall
	inherit from <code>true_type</code>, otherwise it shall inherit from
	<code>false_type</code>.

	<div><table>
<tr><th>Template</th><th>Condition</th></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_sequence;
</code></td><td><code>T</code> is a model of <code>meta::ObjectSequence</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_revertible;
</code></td><td><code>T</code> is a model of <code>meta::Revertible</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct has_name;
</code></td><td><code>T</code> is a model of <code>meta::Named</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct has_type;
</code></td><td><code>T</code> is a model of <code>meta::Typed</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct has_scope;
</code></td><td><code>T</code> is a model of <code>meta::ScopeMember</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_scope;
</code></td><td><code>T</code> is a model of <code>meta::Scope</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_alias;
</code></td><td><code>T</code> is a model of <code>meta::Alias</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_class_member;
</code></td><td><code>T</code> is a model of <code>meta::ClassMember</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_linkable;
</code></td><td><code>T</code> is a model of <code>meta::Linkable</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_global_scope;
</code></td><td><code>T</code> is a model of <code>meta::GlobalScope</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_namespace;
</code></td><td><code>T</code> is a model of <code>meta::Namespace</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_type;
</code></td><td><code>T</code> is a model of <code>meta::Type</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_class;
</code></td><td><code>T</code> is a model of <code>meta::Class</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_enum;
</code></td><td><code>T</code> is a model of <code>meta::Enum</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_constant;
</code></td><td><code>T</code> is a model of <code>meta::Constant</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_variable;
</code></td><td><code>T</code> is a model of <code>meta::Variable</code>.</td></tr>
<tr><td><code>template &lt;Object T&gt;<br/>
struct is_enum_value;
</code></td><td><code>T</code> is a model of <code>meta::EnumValue</code>.</td></tr>
</table></div>

	</p><h4>?.4 Metaobject concepts<span class="section_name">[refl.concepts]</span></h4>

	<div>
	<h5>?.4.1 <code>Object</code></h5>

	<p><code>meta::Object</code> is a concept modelled by stateless anonymous types generated by the compiler which allow access to metadata reflecting specific program declarations.
	</p>

	<pre><code>
	template &lt;typename T&gt; concept bool Object =
	  is_metaobject_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.2 <code>ObjectSequence</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool ObjectSequence =
	  is_sequence_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.3 <code>Revertible</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Revertible =
	  is_revertible_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.4 <code>Named</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Named =
	  has_name_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.5 <code>Typed</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Typed =
	  has_type_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.6 <code>ScopeMember</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool ScopeMember =
	  has_scope_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.7 <code>Scope</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Scope =
	  is_scope_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.8 <code>Alias</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Alias =
	  Named&lt;T&gt; &amp;&amp; is_alias_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.9 <code>ClassMember</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool ClassMember =
	  ScopeMember&lt;T&gt; &amp;&amp; is_class_member_v&lt;T&gt; &amp;&amp; Class&lt;get_scope_t&lt;T&gt;&gt;;
	</code></pre>


	<h5>?.4.10 <code>Linkable</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Linkable =
	  Named&lt;T&gt; &amp;&amp; ScopeMember&lt;T&gt; &amp;&amp; is_linkable_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.11 <code>GlobalScope</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool GlobalScope =
	  Scope&lt;T&gt; &amp;&amp; is_global_scope_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.12 <code>Namespace</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Namespace =
	  Named&lt;T&gt; &amp;&amp; Scope&lt;T&gt; &amp;&amp; ScopeMember&lt;T&gt; &amp;&amp; is_namespace_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.13 <code>NamespaceAlias</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool NamespaceAlias =
	  Namespace&lt;T&gt; &amp;&amp; Alias&lt;T&gt; &amp;&amp; Namespace&lt;get_aliased_t&lt;T&gt;&gt;;
	</code></pre>


	<h5>?.4.14 <code>Type</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Type =
	  Named&lt;T&gt; &amp;&amp; ScopeMember&lt;T&gt; &amp;&amp; is_type_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.15 <code>TypeAlias</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool TypeAlias =
	  Type&lt;T&gt; &amp;&amp; Alias&lt;T&gt; &amp;&amp; Type&lt;get_aliased_t&lt;T&gt;&gt;;
	</code></pre>


	<h5>?.4.16 <code>Class</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Class =
	  Type&lt;T&gt; &amp;&amp; Scope&lt;T&gt; &amp;&amp; is_class_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.17 <code>Enum</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Enum =
	  Type&lt;T&gt; &amp;&amp; is_enum_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.18 <code>EnumClass</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool EnumClass =
	  Enum&lt;T&gt; &amp;&amp; Scope&lt;T&gt;;
	</code></pre>


	<h5>?.4.19 <code>Constant</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Constant =
	  Named&lt;T&gt; &amp;&amp; Typed&lt;T&gt; &amp;&amp; is_constant_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.20 <code>Variable</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool Variable =
	  Named&lt;T&gt; &amp;&amp; Typed&lt;T&gt; &amp;&amp; Linkable&lt;T&gt; &amp;&amp; is_variable_v&lt;T&gt;;
	</code></pre>


	<h5>?.4.21 <code>DataMember</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool DataMember =
	  Variable&lt;T&gt; &amp;&amp; ClassMember&lt;T&gt;;
	</code></pre>


	<h5>?.4.22 <code>MemberType</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool MemberType =
	  Type&lt;T&gt; &amp;&amp; ClassMember&lt;T&gt;;
	</code></pre>


	<h5>?.4.23 <code>EnumValue</code></h5>

	

	<pre><code>
	template &lt;Object T&gt; concept bool EnumValue =
	  Constant&lt;T&gt; &amp;&amp; ScopeMember&lt;T&gt; &amp;&amp; is_enum_value_v&lt;T&gt; &amp;&amp; Enum&lt;get_type_t&lt;T&gt;&gt;;
	</code></pre>

</div>

	<h4>?.5 Metaobject operations<span class="section_name">[refl.ops]</span></h4>

	A <em>MetaobjectOperation</em> returns a single piece of metadata describing
	a particular aspect of the declaration reflected by a <em>Metaobject</em>.
	It shall be a class template taking one or more arguments at least one
	of which is a model of the <em>Metaobject</em> concept.

	<h5>?.5.1 Boolean constant result<span class="section_name">[refl.ops.bool]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning a boolean value,
	shall publicly and unambiguously derive from <code>true_type</code> or
	<code>false_type</code>.
	</p>

	<h5>?.5.2 Integral constant result<span class="section_name">[refl.ops.int]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning an integer or
	<code>enum</code> value, shall publicly and unambiguously derive from
	a specialization of <code>integral_constant</code> with apropriate
	integer or <code>enum</code> type as the first argument.
	</p>

	<p>All <em>MetaobjectOperation</em> templates returning an integer value,
	shall publicly and unambiguously derive from a specialization of
	<code>integral_constant</code> with apropriate integer type as the
	first argument.
	</p>

	<h5>?.5.3 String constant result<span class="section_name">[refl.ops.str]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning a character string,
	shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef const char value_type[N+1];
	static constexpr const char value[N+1];
};
</code></pre>

	<p>where <code>N</code> is the length of the returned string and the
	last element in the <code>value</code> character array, shall be the
	<code>'\0'</code> character.
	The member names <code>value_type</code>, <code>value</code>,
	<code>type</code>, shall be publicly and unambiguously available
	in such <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.4 Metaobject result<span class="section_name">[refl.ops.metaobj]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates yielding another metaobject,
	shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef meta::<em>Object</em> type;
};
</code></pre>

	<p>The member name <code>type</code>, shall be publicly and unambiguously
	available in such <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.5 Type result<span class="section_name">[refl.ops.type]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates yielding a non-metaobject
	type, shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef <em>unspecified</em> type;
};
</code></pre>

	<p>The member name <code>type</code>, shall be publicly and unambiguously
	available in a <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.6 Pointer result<span class="section_name">[refl.ops.ptr]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates returning a pointer or
	a class data member pointer, shall instantiate into a type
	<em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef conditional_t&lt;
		bool(<em>is-non-static-class-data-member</em>),
		<em>unspecified-type</em> <em>unspecified-class</em>::*,
		<em>unspecified-type</em>::*
	&gt; value_type;

	static const value_type value;
};
</code></pre>

	<h5>?.5.7 Operation description<span class="section_name">[refl.ops.desc]</span></h5>

	<div><table><tr><th>Template</th>
<th>Description</th>
<th>Result</th></tr>
<tr><td><pre><code>template &lt;Object T1, Object T2&gt;
struct reflects_same;
</code></pre></td><td>indicates if two metaobjects reflect the same base-level declaration.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Object T&gt;
struct get_source_location;
</code></pre></td><td>returns the source location info of the declaration of a base-level program declaration reflected by a <code>meta::<em>Object</em></code>.</td><td>
		a <code>std::source_location</code> constant
	</td></tr><tr><td><pre><code>template &lt;ObjectSequence T&gt;
struct get_size;
</code></pre></td><td>returns a number of elements in the sequence.</td><td>
		a <code>size_t</code> integral constant
	</td></tr><tr><td><pre><code>template &lt;ObjectSequence T1, size_t Index&gt;
struct get_element;
</code></pre></td><td>returns the i-th <code>meta::<em>Object</em></code> in a <code>meta::<em>ObjectSequence</em></code>.</td><td>
		<code>meta::<em>Object</em></code>
	</td></tr><tr><td><pre><code>template &lt;Named T&gt;
struct get_name;
</code></pre></td><td>returns the basic name of the a named declaration reflected by a <code>meta::<em>Named</em></code>.</td><td>a string constant</td></tr><tr><td><pre><code>template &lt;Typed T&gt;
struct get_type;
</code></pre></td><td>returns the <code>meta::<em>Type</em></code> reflecting the type of base-level declaration with a type reflected by a <code>meta::<em>Typed</em></code>.</td><td>
		<code>meta::<em>Type</em></code>
	</td></tr><tr><td><pre><code>template &lt;ScopeMember T&gt;
struct get_scope;
</code></pre></td><td>returns the <code>meta::<em>Scope</em></code> reflecting the scope of a scoped declaration reflected by a <code>meta::<em>ScopeMember</em></code>.</td><td>
		<code>meta::<em>Scope</em></code>
	</td></tr><tr><td><pre><code>template &lt;Alias T&gt;
struct get_aliased;
</code></pre></td><td>returns the <code>meta::<em>Named</em></code> reflecting the original declaration of a type or namespace alias reflected by a <code>meta::<em>Alias</em></code>.</td><td>
		<code>meta::<em>Named</em></code>
	</td></tr><tr><td><pre><code>template &lt;ClassMember T&gt;
struct is_public;
</code></pre></td><td>returns whether the class member reflected by a <code>meta::<em>ClassMember</em></code> was declared with public access.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Linkable T&gt;
struct is_static;
</code></pre></td><td>returns whether the declaration with storage duration and/or linkage reflected by a <code>meta::<em>Linkable</em></code> was declared with the static specifier.</td><td>a boolean constant</td></tr><tr><td><pre><code>template &lt;Type T&gt;
struct get_reflected_type;
</code></pre></td><td>returns the the base-level type reflected by a <code>meta::<em>Type</em></code>.</td><td>the original type reflected by the argument</td></tr><tr><td><pre><code>template &lt;Class T&gt;
struct get_data_members;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of elements reflecting   the public data members of a class reflected by a <code>meta::<em>Class</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
	</td></tr><tr><td><pre><code>template &lt;Class T&gt;
struct get_all_data_members;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of elements reflecting all   (including the private and protected)   data members of a class reflected by a <code>meta::<em>Class</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
	</td></tr><tr><td><pre><code>template &lt;Class T&gt;
struct get_member_types;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of elements reflecting   the public member types of a class reflected by a <code>meta::<em>Class</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
	</td></tr><tr><td><pre><code>template &lt;Class T&gt;
struct get_all_member_types;
</code></pre></td><td>returns a <code>meta::<em>ObjectSequence</em></code> of elements reflecting all   (including the private and protected)   member types of a class reflected by a <code>meta::<em>Class</em></code>.</td><td>
		<code>meta::<em>ObjectSequence</em></code>
	</td></tr><tr><td><pre><code>template &lt;Constant T&gt;
struct get_constant;
</code></pre></td><td>returns the value of a compile-time constant value reflected by a <code>meta::<em>Constant</em></code>.</td><td>
		a constant value of an unspecified, integer or enum type
	</td></tr><tr><td><pre><code>template &lt;Variable T&gt;
struct get_pointer;
</code></pre></td><td>returns a pointer to the a variable reflected by a <code>meta::<em>Variable</em></code>.   If the variable is a class member then the pointer is a class data member pointer,   otherwise it is a plain pointer.</td><td>a regular or class data member pointer</td></tr></table></div>

	<h4>?.7 The reflection operator<span class="section_name">[reflection.reflexpr]</span></h4>

	<p>TODO
	</p>
</blockquote>

<h2 id="acks">Acknowledgments</h2>

<p>TODO
</p>

<h2>References</h2>

<table class="references">
<tr id="ref-P0194R0">
	<th>[P0194R0]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r0.pdf">
		Chochlík M., Naumann A. -- P0194R0 - Static reflection (revision 4)
	</a>
  </td>
</tr>

<tr id="ref-N4451">
	<th>[N4451]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4451.pdf">
		Chochlík M. -- N4451 - Static reflection (revision 3)
  </a>
  </td>
</tr>

<tr id="ref-N4111">
	<th>[N4111]</th>
	<td>
	<a href="https://isocpp.org/files/papers/n4111.pdf">
		Chochlík M. -- N4111 - Static reflection (revision 2)
	</a>
  </td>
</tr>

<tr id="ref-N3996">
	<th>[N3996]</th>
	<td>
	<a href="https://isocpp.org/files/papers/n3996.pdf">
		Chochlík M. -- N3996 - Static reflection
	</a>
  </td>
</tr>
</table>

</body>
</html>
