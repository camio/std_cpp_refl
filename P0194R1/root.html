<!DOCTYPE
	html
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>P0194R1 — Static reflection</title>
</head>
<body>

<table class="header">
	<tr><th>Document Number:</th><td><b>P0194R1</b>, ISO/IEC JTC1 SC22 WG21</td></tr>
  <tr><th>Date:</th><td>2016-05-17</td></tr>
  <tr><th>Project:</th><td>Programming Language C++</td></tr>
  <tr><th>Audience:</th><td>Reflection(SG7) / EWG</td></tr>
  <tr>
		<th rowspan="2">Authors:</th>
		<td>Matúš Chochlík (<a href="mailto:chochlik@gmail.com">chochlik@gmail.com</a>)</td>
	</tr>
  <tr>
		<td>Axel Naumann (axel.naumann@cern.ch)</td>
	</tr>
</table>

<h1>Static reflection</h1>

<!--Table of Contents -->
<h2>Table of Contents</h2>
<div id="TOC">
	<ul>
		<li><a href="#introduction">Introduction</a>
		</li>
		<li><a href="#revisions">Revision history</a>
		</li>
		<li><a href="#wording">Proposed wording</a>
		</li>
		<li><a href="#acks">Acknowledgments</a>
		</li>
	</ul>
</div>

<h2 id="introduction">Introduction</h2>

<p>TODO
</p>

<h2 id="revisions">Revision history</h2>

<h4>Revision 1 (<a href="#ref-N3996">N3996</a>)</h4>

<p>Describes the method of static reflection
by the means of compiler-generated anonymous types. Introduces the first version
of the metaobject concepts and some possiblities of their implementation.
Also includes discussion about the motivation and the design rationale for the proposal.
</p>

<h4>Revision 2 (<a href="#ref-N4111">N4111</a>)</h4>

<p>Refines the metaobject concepts and introduces
a concrete implementation of their interface by the means of templates similar
to the standard type traits. Describes some additions to the standard library
(mostly meta-programming utilities), which simpilfy the use of the metaobjects.
Answers some questions from the discussion about N3996 and expands the design
rationale.
</p>

<h4>Revision 3 (<a href="#ref-N4451">N4451</a>)</h4>

<p>Incorporates the feedback from the discussion
about N4111 at the Urbana meeting, most notably reduces the set of metaobject concepts and refines their
definitions, removes some of the additions to the standard library added in the previous revisions.
Adds context-dependent reflection.
</p>

<h4>Revision 4 (<a href="#ref-P0194R0">P0194R0</a>)</h4>

<p>Further refines the concepts from N4111; prefixes
the names of the metaobject operations with <code>get_</code>, adds new operations,
replaces the metaobject category tags with new metaobject traits.
Introduces a nested namespace <code>std::meta</code> which contains most
of the reflection-related additions to the standard library.
Rephrases definition of meta objects using Concepts Lite. Specifies the
reflection operator name — <code>reflexpr</code>.
Introduces an experimental implementation of the reflection operator in clang.
Drops the context-dependent reflection from N4111 (will be re-introduced later).
</p>

<h4>Revision 5 (P0194R1)</h4>

Dropped all metaobject traits except <code>is_metaobject</code>. All metaobject
classification is now done by using the concepts.

<h2 id="wording">Proposed wording</h2>

<p>Insert a new element in Table 1, <em>C++ library headers</em> of
[general.namespaces], named <code>&lt;experimental/reflexpr&gt;</code>.
</p>

<p>Insert a new section:
</p>

<blockquote class="std">
	<h3>? Compile-time reflection <span class="section_name">[refl]</span></h3>

	<h4>?.1 General description <span class="section_name">[refl.general]</span></h4>

	<p>Compile-time constant metadata describing various aspects of a compiled program
	are provided indirectly by the means of types generated by the compiler —
	<em>metaobjects</em>.

	A <em>Metaobject</em> is an anonymous type <em>reflecting</em>
	(representing) a particular declaration in a C++ program. It can be
	reasoned-about at compile-time and provides access to <em>metadata</em>
	describing various properties of the reflected declaration through
	a set of templates.

	The <em>metaobject</em> types themselves are opaque, without any visible
	internal structure and they cannot be instantiated.
	</p>

	<p>The metaobjects shall be generated on demand by the compiler as
	the result of the invocation of the <code>reflexpr</code> operator.
	</p>
	
	<p>The actual metadata can be obtained by instantiating templates constituting
	the <em>interface</em> of the metaobjects. Each template serves a particular
	purpose and provides a single piece of metadata. These templates are
	collectively referred to as <em>metaobject operations</em>.
	</p>

	<p>Metaobjects reflecting different kinds of declarations conform to different
	<em>metaobject concepts</em> and have different interfaces — sets of templates
	applicable on the metaobjects. These concepts can also be used for
	metaobject classification.

	<p>Metaobject concepts form a generalization-specialization hierarchy, with
	<code>meta::Object</code> being the common generalization for all metaobjects.
	</p>

	<h4>?.2 Metaobject trait<span class="section_name">[refl.trait]</span></h4>

	<p>A new <em>UnaryTypeTrait</em> — <code>is_metaobject</code> shall be added
	to section [meta.unary.cat] to distinguish between metaobject types generated
	by the compiler and all other types.
	</p>

<pre><code>
namespace std {
namespace experimental {

template &lt;typename T&gt; struct is_metaobject;

} // namespace experimental
} // namespace std
</code></pre>

<pre>
[Example:
<code>
is_metaobject_v&lt;int&gt;;                   // false
is_metaobject_v&lt;void&gt;;                  // false
is_metaobject_v&lt;string&gt;;                // false
is_metaobject_v&lt;reflexpr(int)&gt;;         // true
is_metaobject_v&lt;reflexpr(std)&gt;;         // true
is_metaobject_v&lt;reflexpr(std::string)&gt;; // true
</code>
— end example]
</pre>

	<h4>?.3 Header <code>&lt;experimental/reflexpr&gt;</code> synopsis<span class="section_name">[refl.synopsis]</span></h4>

	<object class="htmlc" name="synopsis" type="text/html" data="synopsis.htmlc"></object>


	<h4>?.4 Metaobject concepts<span class="section_name">[refl.concepts]</span></h4>

	<object class="htmlc" name="concepts" type="text/html" data="concepts.htmlc"></object>

<pre>
[Example:
<code>
TODO
</code>
— end example]
</pre>

	<h4>?.5 Metaobject operations<span class="section_name">[refl.ops]</span></h4>

	A <em>MetaobjectOperation</em> returns a single piece of metadata describing
	a particular aspect of the declaration reflected by a <em>Metaobject</em>.
	It shall be a class template taking one or more arguments at least one
	of which is a model of the <em>Metaobject</em> concept.
	The result of a <em>MetaobjectOperation</em> can be either a compile-time
	constant value a <code>const</code> pointer or a type.

	<h5>?.5.1 Boolean constant result<span class="section_name">[refl.ops.bool]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning a boolean value,
	shall publicly and unambiguously derive from <code>true_type</code> or
	<code>false_type</code>.
	</p>

	<h5>?.5.2 Integral constant result<span class="section_name">[refl.ops.int]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning an integer or
	<code>enum</code> value, shall publicly and unambiguously derive from
	a specialization of <code>integral_constant</code> with apropriate
	integer or <code>enum</code> type as the first argument.
	</p>

	<h5>?.5.3 String constant result<span class="section_name">[refl.ops.str]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning a character string,
	shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef const char value_type[N+1];
	static constexpr const char value[N+1];
};
</code></pre>

	<p>where <code>N</code> is the length of the returned string and the
	last element in the <code>value</code> character array, shall be the
	<code>'\0'</code> character.
	The member names <code>value_type</code>, <code>value</code>,
	<code>type</code>, shall be publicly and unambiguously available
	in such <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.4 Metaobject result<span class="section_name">[refl.ops.metaobj]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates yielding another metaobject,
	shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef meta::<em>Object</em> type;
};
</code></pre>

	<p>The member name <code>type</code>, shall be publicly and unambiguously
	available in such <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.5 Type result<span class="section_name">[refl.ops.type]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates yielding a non-metaobject
	type, shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef <em>unspecified</em> type;
};
</code></pre>

	<p>The member name <code>type</code>, shall be publicly and unambiguously
	available in a <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.6 Pointer result<span class="section_name">[refl.ops.ptr]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates returning a pointer or
	a class data member pointer, shall instantiate into a type
	<em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef conditional_t&lt;
		bool(<em>is-non-static-class-data-member</em>),
		<em>unspecified-type</em> <em>unspecified-class</em>::*,
		<em>unspecified-type</em>*
	&gt; value_type;

	static const value_type value;
};
</code></pre>

	<h5>?.5.7 Operation description<span class="section_name">[refl.ops.desc]</span></h5>

	<object class="htmlc" name="concepts" type="text/html" data="operations.htmlc"></object>

	<p>The <code>get_name</code> operation returns the type, alias, namespace, etc.
	name without any qualifiers, asterisks, ampersands, angle or square brackets, etc.
	</p>

<pre>
[Example:
<code>
using foo = int;
using bar = foo;
namespace std = baz;

meta::get_name_v&lt;reflexpr(int)&gt;;    // "int"
meta::get_name_v&lt;reflexpr(std)&gt;;    // "std"
meta::get_name_v&lt;reflexpr(foo)&gt;;    // "foo"
meta::get_name_v&lt;reflexpr(bar)&gt;;    // "bar"
meta::get_name_v&lt;reflexpr(baz)&gt;;    // "baz"
</code>
— end example]
</pre>

<pre>
[Example:
<code>
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;)&gt;;                                // "vector"
meta::get_name_v&lt;reflexpr(const std::pair)&gt;;                                 // "pair"
meta::get_name_v&lt;reflexpr(volatile std::size_t* [10])&gt;;                      // "size_t"
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;* (*)(std::vector&lt;double&gt;&amp;))&gt;;     // ""
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;* (*pfoo)(std::vector&lt;double&gt;&amp;))&gt;; // "pfoo"
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;* foo(std::vector&lt;double&gt;&amp;))&gt;;     // "foo"
meta::get_name_v&lt;reflexpr(std::chrono)&gt;;                                     // "chrono"
meta::get_name_v&lt;reflexpr(std::nothrow)&gt;;                                    // "nothrow"
meta::get_name_v&lt;reflexpr(std::string::npos)&gt;;                               // "npos"
</code>
— end example]
</pre>

	<h4>?.6 The reflection operator<span class="section_name">[refl.reflexpr]</span></h4>

	<p>TODO
	</p>

	<h5>?.6.1 Reverse reflection<span class="section_name">[refl.reflexpr.rev]</span></h5>

</blockquote>

<h2 id="acks">Acknowledgments</h2>

<p>TODO
</p>

<h2>References</h2>

<table class="references">
<tr id="ref-P0194R0">
	<th>[P0194R0]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r0.pdf">
		Chochlík M., Naumann A. — P0194R0 - Static reflection (revision 4)
	</a>
  </td>
</tr>

<tr id="ref-N4451">
	<th>[N4451]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4451.pdf">
		Chochlík M. — N4451 - Static reflection (revision 3)
  </a>
  </td>
</tr>

<tr id="ref-N4111">
	<th>[N4111]</th>
	<td>
	<a href="https://isocpp.org/files/papers/n4111.pdf">
		Chochlík M. — N4111 - Static reflection (revision 2)
	</a>
  </td>
</tr>

<tr id="ref-N3996">
	<th>[N3996]</th>
	<td>
	<a href="https://isocpp.org/files/papers/n3996.pdf">
		Chochlík M. — N3996 - Static reflection
	</a>
  </td>
</tr>
</table>

</body>
</html>
