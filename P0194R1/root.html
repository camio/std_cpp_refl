<!DOCTYPE
	html
	PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
	<meta charset="utf-8"/>
	<link rel="stylesheet" type="text/css" href="style.css"/>
	<title>P0194R1 — Static reflection</title>
</head>
<body>

<table class="header">
	<tr><th>Document Number:</th><td><b>P0194R1</b>, ISO/IEC JTC1 SC22 WG21</td></tr>
  <tr><th>Date:</th><td>2016-05-17</td></tr>
  <tr><th>Project:</th><td>Programming Language C++</td></tr>
  <tr><th>Audience:</th><td>Reflection(SG7) / EWG</td></tr>
  <tr>
		<th rowspan="2">Authors:</th>
		<td>Matúš Chochlík (<a href="mailto:chochlik@gmail.com">chochlik@gmail.com</a>)</td>
	</tr>
  <tr>
		<td>Axel Naumann (axel.naumann@cern.ch)</td>
	</tr>
</table>

<h1>Static reflection</h1>

<!--Table of Contents -->
<h2>Table of Contents</h2>
<div id="TOC">
	<ul>
		<li><a href="#introduction">Introduction</a>
		</li>
		<li><a href="#revisions">Revision history</a>
		</li>
		<li><a href="#wording">Proposed wording</a>
		</li>
		<li><a href="#acks">Acknowledgments</a>
		</li>
	</ul>
</div>

<h2 id="introduction">Introduction</h2>

<p>TODO
</p>

<h2 id="revisions">Revision history</h2>

<h4>Revision 1 (<a href="#ref-N3996">N3996</a>)</h4>

<p>Describes the method of static reflection
by the means of compiler-generated anonymous types. Introduces the first version
of the metaobject concepts and some possiblities of their implementation.
Also includes discussion about the motivation and the design rationale for the proposal.
</p>

<h4>Revision 2 (<a href="#ref-N4111">N4111</a>)</h4>

<p>Refines the metaobject concepts and introduces
a concrete implementation of their interface by the means of templates similar
to the standard type traits. Describes some additions to the standard library
(mostly meta-programming utilities), which simpilfy the use of the metaobjects.
Answers some questions from the discussion about N3996 and expands the design
rationale.
</p>

<h4>Revision 3 (<a href="#ref-N4451">N4451</a>)</h4>

<p>Incorporates the feedback from the discussion
about N4111 at the Urbana meeting, most notably reduces the set of metaobject concepts and refines their
definitions, removes some of the additions to the standard library added in the previous revisions.
Adds context-dependent reflection.
</p>

<h4>Revision 4 (<a href="#ref-P0194R0">P0194R0</a>)</h4>

<p>Further refines the concepts from N4111; prefixes
the names of the metaobject operations with <code>get_</code>, adds new operations,
replaces the metaobject category tags with new metaobject traits.
Introduces a nested namespace <code>std::meta</code> which contains most
of the reflection-related additions to the standard library.
Rephrases definition of meta objects using Concepts Lite. Specifies the
reflection operator name — <code>reflexpr</code>.
Introduces an experimental implementation of the reflection operator in clang.
Drops the context-dependent reflection from N4111 (will be re-introduced later).
</p>

<h4>Revision 5 (P0194R1)</h4>

Dropped all metaobject traits except <code>is_metaobject</code>. All metaobject
classification is now done by using the concepts.

<h2 id="wording">Proposed wording</h2>

<p>Insert a new element in Table 1, <em>C++ library headers</em> of
[general.namespaces], named <code>&lt;experimental/reflexpr&gt;</code>.
</p>

<p>Insert a new section:
</p>

<blockquote class="std">
	<h3>? Compile-time reflection <span class="section_name">[refl]</span></h3>

	<h4>?.1 General description <span class="section_name">[refl.general]</span></h4>

	<p>Compile-time constant metadata describing various aspects of a compiled program
	are provided indirectly by the means of types generated by the compiler —
	<em>metaobjects</em>.

	A <em>Metaobject</em> is an anonymous type <em>reflecting</em>
	(representing) a particular declaration in a C++ program. It can be
	reasoned-about at compile-time and provides access to <em>metadata</em>
	describing various properties of the reflected declaration through
	a set of templates.

	The <em>metaobject</em> types themselves are opaque, without any visible
	internal structure and they cannot be instantiated.
	</p>

	<p>The metaobjects shall be generated on demand by the compiler as
	the result of the invocation of the <code>reflexpr</code> operator.
	</p>
	
	<p>The actual metadata can be obtained by instantiating templates constituting
	the <em>interface</em> of the metaobjects. Each template serves a particular
	purpose and provides a single piece of metadata. These templates are
	collectively referred to as <em>metaobject operations</em>.
	</p>

	<p>Metaobjects reflecting different kinds of declarations conform to different
	<em>metaobject concepts</em> and have different interfaces — sets of templates
	applicable on the metaobjects. These concepts can also be used for
	metaobject classification.

	<p>Metaobject concepts form a generalization-specialization hierarchy, with
	<code>meta::Object</code> being the common generalization for all metaobjects.
	</p>

	<h4>?.2 Metaobject trait<span class="section_name">[refl.trait]</span></h4>

	<p>A new <em>UnaryTypeTrait</em> — <code>is_metaobject</code> shall be added
	to section [meta.unary.cat] to distinguish between metaobject types generated
	by the compiler and all other types.
	</p>

<pre><code>
namespace std {
namespace experimental {

template &lt;typename T&gt; struct is_metaobject;

} // namespace experimental
} // namespace std
</code></pre>

<pre>
[Example:
<code>
is_metaobject_v&lt;int&gt;;                   // false
is_metaobject_v&lt;void&gt;;                  // false
is_metaobject_v&lt;string&gt;;                // false
is_metaobject_v&lt;reflexpr(int)&gt;;         // true
is_metaobject_v&lt;reflexpr(std)&gt;;         // true
is_metaobject_v&lt;reflexpr(std::string)&gt;; // true
</code>
— end example]
</pre>

	<h4>?.3 Header <code>&lt;experimental/reflexpr&gt;</code> synopsis<span class="section_name">[refl.synopsis]</span></h4>

	<object class="htmlc" name="synopsis" type="text/html" data="synopsis.htmlc"></object>


	<h4>?.4 Metaobject concepts<span class="section_name">[refl.concepts]</span></h4>

	<object class="htmlc" name="concepts" type="text/html" data="concepts.htmlc"></object>

	<p>[Note: Metaobjects reflecting anonymous types, anonymous namespaces
	or the global scope do not satisfy the <code>meta::Named</code> concept.
	This means that they do not implement the <code>meta::get_name</code> operation.
	— end note]
	</p>

	<p>[Note: Metaobjects reflecting the global scope do not satisfy the
	<code>meta::ScopeMember</code> concept.
	This means that they do not implement the <code>meta::get_scope</code> operation.
	— end note]
	</p>

	<p>[Note: Metaobjects reflecting strongly-typed enumerations conform
	to the <code>meta::Scope</code> concept, regular enumerations do not.
	— end note]
	</p>


<pre>
[Example:
<code>
TODO
</code>
— end example]
</pre>

	<h4>?.5 Metaobject operations<span class="section_name">[refl.ops]</span></h4>

	A <em>MetaobjectOperation</em> returns a single piece of metadata describing
	a particular aspect of the declaration reflected by a <em>Metaobject</em>.
	It shall be a class template taking one or more arguments at least one
	of which is a model of the <em>Metaobject</em> concept.
	The result of a <em>MetaobjectOperation</em> can be either a compile-time
	constant value a <code>const</code> pointer or a type.

	<h5>?.5.1 Boolean constant result<span class="section_name">[refl.ops.bool]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning a boolean value,
	shall publicly and unambiguously derive from <code>true_type</code> or
	<code>false_type</code>.
	</p>

	<h5>?.5.2 Integral constant result<span class="section_name">[refl.ops.int]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning an integer or
	<code>enum</code> value, shall publicly and unambiguously derive from
	a specialization of <code>integral_constant</code> with apropriate
	integer or <code>enum</code> type as the first argument.
	</p>

	<h5>?.5.3 String constant result<span class="section_name">[refl.ops.str]</span></h5>

	<p>All <em>MetaobjectOperation</em> templates returning a character string,
	shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef const char value_type[N+1];
	static constexpr const char value[N+1];
};
</code></pre>

	<p>where <code>N</code> is the length of the returned string and the
	last element in the <code>value</code> character array, shall be the
	<code>'\0'</code> character.
	The member names <code>value_type</code>, <code>value</code>,
	<code>type</code>, shall be publicly and unambiguously available
	in such <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.4 Metaobject result<span class="section_name">[refl.ops.metaobj]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates yielding another metaobject,
	shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef meta::<em>Object</em> type;
};
</code></pre>

	<p>The member name <code>type</code>, shall be publicly and unambiguously
	available in such <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.5 Type result<span class="section_name">[refl.ops.type]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates yielding a non-metaobject
	type, shall instantiate into a type <em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef <em>unspecified</em> type;
};
</code></pre>

	<p>The member name <code>type</code>, shall be publicly and unambiguously
	available in a <em>MetaobjectOperation</em>.
	</p>

	<h5>?.5.6 Pointer result<span class="section_name">[refl.ops.ptr]</span></h5>

	<p>The <em>MetaobjectOperation</em> templates returning a pointer or
	a class data member pointer, shall instantiate into a type
	<em>equivalent</em> to the following:
	</p>

<pre><code>
struct MetaobjectOperation
{
	typedef conditional_t&lt;
		bool(<em>is-non-static-class-data-member</em>),
		<em>unspecified-type</em> <em>unspecified-class</em>::*,
		<em>unspecified-type</em>*
	&gt; value_type;

	static const value_type value;
};
</code></pre>

	<h5>?.5.7 Operation description<span class="section_name">[refl.ops.desc]</span></h5>

	<object class="htmlc" name="concepts" type="text/html" data="operations.htmlc"></object>

	<p>The <code>get_name</code> operation returns the type, alias, namespace, etc.
	name without any qualifiers, asterisks, ampersands, angle or square brackets, etc.
	</p>

<pre>
[Example:
<code>
using foo = int;
using bar = foo;
namespace std = baz;

meta::get_name_v&lt;reflexpr(int)&gt;;    // "int"
meta::get_name_v&lt;reflexpr(std)&gt;;    // "std"
meta::get_name_v&lt;reflexpr(foo)&gt;;    // "foo"
meta::get_name_v&lt;reflexpr(bar)&gt;;    // "bar"
meta::get_name_v&lt;reflexpr(baz)&gt;;    // "baz"
</code>
— end example]
</pre>

<pre>
[Example:
<code>
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;)&gt;;                                // "vector"
meta::get_name_v&lt;reflexpr(const std::pair)&gt;;                                 // "pair"
meta::get_name_v&lt;reflexpr(volatile std::size_t* [10])&gt;;                      // "size_t"
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;* (*)(std::vector&lt;double&gt;&amp;))&gt;;     // ""
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;* (*pfoo)(std::vector&lt;double&gt;&amp;))&gt;; // "pfoo"
meta::get_name_v&lt;reflexpr(std::vector&lt;int&gt;* foo(std::vector&lt;double&gt;&amp;))&gt;;     // "foo"
meta::get_name_v&lt;reflexpr(std::chrono)&gt;;                                     // "chrono"
meta::get_name_v&lt;reflexpr(std::nothrow)&gt;;                                    // "nothrow"
meta::get_name_v&lt;reflexpr(std::string::npos)&gt;;                               // "npos"
</code>
— end example]
</pre>

<pre>
[Example:
<code>
auto l = [](void) { };
meta::get_name_v&lt;reflexpr(::)&gt;;           // "error"
meta::get_name_v&lt;reflexpr(decltype(l))&gt;;  // "error"
</code>
— end example]
</pre>

	<h4>?.6 The reflection operator<span class="section_name">[refl.reflexpr]</span></h4>

	<p>The value of the <code>reflexpr</code> is a type satisfying <code>meta::Object</code>
      and other <code>meta</code> concepts, depending on the operand.
      The returned type is implementation defined.
      Meta-operations on it describe the operand.
    </p>
    <p>
      The <code>reflexpr</code> operator takes an <em>id-expression</em> (5.1), or
      <em>access-specifier</em> (10) as operand, or nothing.
      The <em>id-expression</em> must be uniquely resolved through regular lookup, as if used
      outside of the <code>reflexpr</code> operator.
      Otherwise, the expression is ill-formed.
	</p>
      <ul>
        <li>If the operand is a <em>typedef-name</em>, the result will be satisfying
          <code>TypeAlias</code>.</li>
        <li>Otherwise, if the operand is a <em>class-name</em>, the result will be satisfying
          <code>Class</code>.</li>
        <li>Otherwise, if the operand is a <em>enum-name</em>, the result will be satisfying
          <code>EnumClass</code> if the <em>enum-name</em> refers to a <em>scoped
          enumerator</em> (7.2), or <code>Enum</code> if the <em>enum-name</em> refers to an
          <em>unscoped enumerator</em>.</li>
        <li>Otherwise, if the operand is a <em>type-name</em>, the result will be satisfying
          <code>Type</code>.</li>
        <li>Otherwise, if the operand is the name of a <em>namespace-alias-declaration</em>,
          the result will be satisfying <code>NamespaceAlias</code>.</li>
        <li>Otherwise, if the operand is a <em>namespace-name</em>, the result will be
          satisfying <code>Namespace</code>.</li>
      </ul>
    <p>
      If the <em>id-expression</em> is a <em>type-name</em>, and the scope of its declaration
      is a class, then the result of <code>reflexpr</code> is also satisfying
      <code>MemberType</code>.
    </p>
    <p>
      The invocation of <code>reflexpr</code> on all other kinds of <em>id-expressions</em>
      is ill-formed. [Note:
      <code>
        reflexpr() // reflects the global namespace
        reflexpr(::) // reflects the global namespace
        reflexpr(std) // reflects the namespace
        reflexpr(std::size_t) // reflects the type
        reflexpr(std::launch) // reflects the enum type
        reflexpr(std::vector&lt;int&gt;) // reflects the class

        reflexpr(1) // ill-formed
        reflexpr(std::sin) // ill-formed
        reflexpr(std::vector) // ill-formed
        reflexpr(is_same_&lt;void,void&gt;) // ill-formed
      </code>
— end note]
    </p>
    <p>If the operand is an <em>access-specifier</em>, then the result of
      <code>reflexpr</code> is satisfying <code>Specifier</code>.
    </p>

	<h5>?.6.1 Redeclarations<span class="section_name">[refl.reflexpr.redecl]</span></h5>

	<p>The meta data queried by <code>reflexpr</code> depends on the point of invocation
	of the operator; only declarations in front of the invocation will be visible.
	Subsequent invocations are independent of prior invocations, as if all compiler
	generated types were unique to each <code>reflexpr</code> invocation.
	</p>

<pre>
[Example:
<code>
struct foo;
using meta_foo_fwd1 = reflexpr(foo);
constexpr size_t n1 = get_size_v&lt;get_data_members_t&lt;meta_foo_fwd1&gt;&gt;; // 0

struct foo;
using meta_foo_fwd2 = reflexpr(foo);
constexpr size_t n2 = get_size_v&lt;get_data_members_t&lt;meta_foo_fwd2&gt;&gt;; // 0

constexpr bool b1 = is_same_v&lt;meta_foo_fwd1, meta_foo_fwd2&gt;;             // <em>unspecified</em>
constexpr bool b2 = meta::reflects_same_v&lt;meta_foo_fwd1, meta_foo_fwd2&gt;; // true

struct foo { int a,b,c,d; };
using meta_foo = reflexpr(foo);
constexpr size_t n3 = get_size_v&lt;get_data_members_t&lt;meta_foo&gt;&gt;;      // 4

constexpr bool b3 = is_same_v&lt;meta_foo_fwd1, meta_foo&gt;;             // false
constexpr bool b4 = meta::reflects_same_v&lt;meta_foo_fwd1, meta_foo&gt;; // true
</code>
— end example]
</pre>

	<h5>?.6.2 Required header<span class="section_name">[refl.reflexpr.header]</span></h5>

	<p>If the header <code>&lt;reflexpr&gt;</code> is not included prior to a use
	of <code>reflexpr</code>, the program is ill-formed.
	This header file defines the templates implementing the operations
	on metaobjects as described above.
	</p>

	<h5>?.6.3 Reverse reflection<span class="section_name">[refl.reflexpr.rev]</span></h5>

	<p>If a metaobject conforming to the <code>meta::Revertible</code> concept
	is passed as the argument to the <code>reflexpr</code> operator,
	then this invocation shall have the same effect as if the name of the
	original declaration reflected by the metaobject was used.
	</p>

	<p>For instance if a <code>meta::Type</code> is passed as the argument,
	then <code>reflexpr</code> should return the reflected type.
	In this case the result of reverse reflection is the same as the result
	of the <code>meta::get_reflected_type</code> operation.
	</p>

<pre>
[Example:
<code>
using meta_int = reflexpr(int);
is_same_t&lt;int, reflexpr(meta_int)&gt;; // true
is_same_t&lt;int, meta::get_reflected_type_t&lt;meta_int&gt;&gt;; // true

reflexpr(meta_int) x = 123;   // valid (same as int x;)

struct my_struct
{
	reflexpr(meta_int) i; // valid (same as int i;)
};
</code>
— end example]
</pre>

[Note: If a metaobject not conforming to the <code>meta::Revertible</code> concept
is passed to the <code>reflexpr</code> operator then the result is undefined.
— end note]

</blockquote>

<h2 id="acks">Acknowledgments</h2>

<p>TODO
</p>

<h2>References</h2>

<table class="references">
<tr id="ref-P0194R0">
	<th>[P0194R0]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0194r0.pdf">
		Chochlík M., Naumann A. — P0194R0 - Static reflection (revision 4)
	</a>
  </td>
</tr>

<tr id="ref-N4451">
	<th>[N4451]</th>
	<td>
	<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4451.pdf">
		Chochlík M. — N4451 - Static reflection (revision 3)
  </a>
  </td>
</tr>

<tr id="ref-N4111">
	<th>[N4111]</th>
	<td>
	<a href="https://isocpp.org/files/papers/n4111.pdf">
		Chochlík M. — N4111 - Static reflection (revision 2)
	</a>
  </td>
</tr>

<tr id="ref-N3996">
	<th>[N3996]</th>
	<td>
	<a href="https://isocpp.org/files/papers/n3996.pdf">
		Chochlík M. — N3996 - Static reflection
	</a>
  </td>
</tr>
</table>

</body>
</html>
