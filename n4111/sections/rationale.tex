\section{Rationale}

This section explains some of the design decisions behind this proposal and
answers several frequently asked questions.

\subsection{Why metaobjects, why not reflect directly?}

{\textbf Q:}{\em Why should we define a set of metaobject concepts, let the compiler generate
models of these concepts and use those to obtain the metadata? Why not just extend the existing
type traits?}

{\textbf A:} The most important reason is completeness or scope of reflection.
Type traits (as they are defined now) work just with types. A reflection facility should
however provide much more metadata.
It should be able to reflect namespaces, functions, constructors, inheritance, variables, etc.

For example:

\begin{minted}{cpp}
pair<long, string> my_var;

// OK, we can print the name of the type of a variable:
cout << type_name<decltype(my_var)>() << endl;
// But we really, really want to print the name of the variable
// (without the use of the preprocessor)
cout << type_name<my_var>() << endl; // Error
// similar with namespaces:
cout << type_name<std::chrono>() << endl; // Error
// etc.
\end{minted}


Doing reflection with type traits limits the scope, because of the rules defining what
can be a template parameter. This rules could be updated to allow for example an expression
representing a particular class constructor to  be passed as a template argument.
Also currently there is no expression for specifying (not invoking) a constructor
(for example for the purpose of taking its address), so additional rules would have
to be added.
This would (in our opinion) be a much more drastic change to the standard, than
the adoption of this proposal.

Second reason is access to private and protected members. There are many use-cases where
access to non-public class members through reflection is desired. If reflection was
done through type traits directly on the class members, it would be either impossible
to reflect non-public members or the access rules would have to be changed to somehow
allow access in reflection expressions:

\begin{minted}{cpp}
class C
{
private:
	typedef int T;
public:
};

assert(some_trait<C::T>::value); //OK, we are reflecting so we have access
\end{minted}

but not outside:

\begin{minted}{cpp}
C::T x = 0; // Error, C::T is private
\end{minted}

With the reflection operator like \verb@mirrored(X)@, the access rules would have
to be updated only to allow the reflection operator to have access to everthing.
At the first glance, the following two expressions;

\begin{minted}{cpp}
some_trait<C::T>::value
\end{minted}

and

\begin{minted}{cpp}
mirrored(C::T)
\end{minted}

look similar and so the changes to the access rules could seem similar too, but
that is not the case. The (single) \verb@mirrored@ operator would have special status,
on the other hand type traits are regular templates (with some magic inside) and
all (several dozens of them) would need to be distinguished from all the other templates
in the \verb@std@ namespace, which should not have private access.

Having said that, we do not object to extending the type traits where it does make sense.

One other reason for having a new reflection operator is, that there already is an
existing (very limited) reflection operator, namely \verb@typeid@ which "returns"
a compiler-generated "metaobject" -- \verb@std::type_info@. We are aware that there
are differences between \verb@typeid@ and \verb@mirrored@, but the basic idea is similar.

\subsection{Why are the metaobjects anonymous?}

{\textbf Q:}{\em Why should the metaobjects be anonymous types as opposed to
types with well defined and standardized names or concrete template classes, (possibly with some
special kind of parameter accepting different arguments than types and constants)?}

{\textbf A:} We wanted to avoid defining a specific naming convention, because it would
be difficult to do so and very probably not user friendly (see C++ name mangling). There
already is a precedent for anonymous types -- for example C++ {\em lambdas}.

Another option would be to define a concrete set of template classes like:

\begin{minted}{cpp}
namespace std {

template <typename T>
class meta_type /* Model of MetaType */
{ };

}
\end{minted}

which could work with types, classes, etc., but would not work with namespaces, constructors,
etc. (see also the Q/A above):

\begin{minted}{cpp}
namespace std {

template <something X> //<- Problem
class meta_constructor /* Model of MetaConstructor */
{ };

template <something X> //<- Problem
class meta_namespace /* Model of MetaNamespace */
{ };

}

typedef std::meta_namespace<std> meta_std; //<- Problem
\end{minted}

Instead of this, the metaobjects are anonymous and their (internal) identification
is left to the compiler. From the users POV, the metaobject can be distinguished
by the means of the metaobject traits and tags as \hyperref[section-Concepts]{described above}.
