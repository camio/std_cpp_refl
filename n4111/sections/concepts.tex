\section{Metaobject concepts}

We propose that the basic metadata describing a program written
in C++ should be made available through a set of {\em anonymous} types
and related functions and templates
defined by the compiler. These types should describe various program
constructs like, namespaces, types, typedefs, classes, their member variables
(member data), member functions, inheritance, templates, template parameters,
enumerated values, etc.

The compiler should generate metadata for the program constructs defined
in the currently processed translation unit. Indexed sets (ranges) of metaobjects,
like scope members, parameters of a function, etc. should be listed
in the order of appearance in the processed source code.

Since we want the metadata to be available at compile-time,
different base-level constructs should be reflected by
{\em "statically" different} metaobjects and thus by {\em different} types.
For example a metaobject reflecting the global scope namespace should
be a different {\em type} than a metaobject reflecting the \verb@std@
namespace, a metaobject reflecting the \verb@int@ type should
have a different type then a metaobject reflecting the \verb@double@
type, a metaobject reflecting \verb@::foo(int)@ function should
have a different type than a metaobject reflecting \verb@::foo(double)@,
function, etc.

In a manner of speaking these special types (metaobjects) should become
"instances" of the meta-level concepts (static interfaces which
should not exist as concrete types, but rather only at the
"specification-level" similar for example to the iterator concepts).
This section describes a set of metaobject concepts,
their interfaces, tag types for metaobject classification and
functions (or operators) providing access to the metaobjects.

This section conceptualy describes the requirements that various metaobjects
need to satisfy in order to be considered models of the individual
concepts.

Unless stated otherwise all additions proposed and described below should
go into the \verb@std@ namespace. Alternatively, if any of the definitions
proposed here clash with existing members (or new members proposed elsewhere)
of the \verb@std@ namespace then they can be nested in a namespace like
\verb@std::meta@ or \verb@std::mirror@.

Also note, that in the sections below, the exaples use names for concrete
metaobjects with names like \verb@__meta_std_string@. This convention
is {\em NOT} part of this proposal. The actual naming of the metaobjects
should be left to the compiler implementations and for all purposes
from the users point of view the metaobjects should be anonymous types.

\input{sections/concepts_traits.tex}
\input{sections/concepts_string.tex}
\input{sections/concepts_sequence.tex}
\input{sections/concepts_object.tex}
\input{sections/concepts_specifier.tex}
\input{sections/concepts_named.tex}
\input{sections/concepts_scoped.tex}
\input{sections/concepts_named_scoped.tex}
\input{sections/concepts_scope.tex}
\input{sections/concepts_class_member.tex}
\input{sections/concepts_global_scope.tex}
\input{sections/concepts_namespace.tex}
\input{sections/concepts_type.tex}
\input{sections/concepts_typedef.tex}
\input{sections/concepts_class.tex}
\input{sections/concepts_ovld_func.tex}
\input{sections/concepts_function.tex}
\input{sections/concepts_initializer.tex}
\input{sections/concepts_constructor.tex}
\input{sections/concepts_operator.tex}
\input{sections/concepts_template.tex}
\input{sections/concepts_template_param.tex}
\input{sections/concepts_instantiation.tex}
\input{sections/concepts_enum.tex}
\input{sections/concepts_enum_class.tex}
\input{sections/concepts_inheritance.tex}
\input{sections/concepts_variable.tex}
\input{sections/concepts_parameter.tex}
\input{sections/concepts_constant.tex}
