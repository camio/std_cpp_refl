\subsection{MetaNamed}
\label{concept-MetaNamed}

\begin{tikzpicture}
\node[concept] (Metaobject) {Metaobject};
\node[concept] (MetaNamed) [right=of Metaobject] {MetaNamed}
	edge[inheritance] (Metaobject);
\end{tikzpicture}

\meta{Named} is a \meta{object} reflecting program constructs, which have a name
(are identified by an identifier) like namespaces, types, functions, variables, parameters, etc.

In addition to the requirements inherited from \meta{object}, the following requirements must
be satisfied:

The \verb@has_name@ template class specialization for a \meta{Named} should
inherit from \verb@true_type@:

\begin{minted}{cpp}
template <>
struct has_name<MetaNamed>
 : true_type
{ };
\end{minted}

\subsubsection{\texttt{base\_name}}

A template class \verb@base_name@ should be defined an should return the base name
of the reflected construct, without the nested name specifier nor any qualifications
or other decorations, as a
\concept{StringConstant}:

\begin{minted}{cpp}
template <typename T>
struct base_name;

template <>
struct base_name<MetaNamed>
 : StringConstant
{ };
\end{minted}

For example, if \verb@__meta_std_size_t@ reflects the \verb@std::size_t@ type,
then the matching specialization of \verb@base_name@ could be implmented in the following
way:

\begin{minted}{cpp}
template <>
struct base_name<__meta_std_size_t>
 : string_constant<'s','i','z','e','_','t'>
{ };
\end{minted}

where the \verb@string_constant<'s','i','z','e','_','t'>@ class is a model
of \concept{StringConstant} as described above.

For namespace \verb@std@ the value should be \verb@"std"@, for namespace
\verb@foo::bar::baz@ it should be \verb@"baz"@, for the global scope the
value should be an empty string.

For \verb@unsigned long int * const *@ it should be \verb@"unsigned long int"@.

For \verb@std::vector<int>::iterator@ it should be \verb@"iterator"@. For derived,
qualified types like \verb@volatile std::vector<const foo::bar::fubar*> * const *@
it should be \verb@"vector"@, etc.

\subsubsection{\texttt{full\_name}}

A template class \verb@full_name@ should be defined and should return the fully
qualified name of the reflected construct, including the nested name specifier
and all qualifiers.

For namespace \verb@std@ the value 
should be \verb@"std"@, for namespace \verb@foo::bar::baz@ the value should
be \verb@"foo::bar::baz"@, for the global scope the value should be an empty
\concept{StringConstant}.
For \verb@std::vector<int>::iterator@ it should be \verb@"std::vector<int>::iterator"@.
For derived qualified types like
\verb@volatile std::vector<const foo::bar::fubar*> * const *@ it should be defined as
\verb@"volatile std::vector<const foo::bar::fubar*> * const *"@, etc.

\begin{minted}{cpp}
template <typename T>
struct full_name;

template <>
struct full_name<MetaNamedScoped>
 : StringConstant
{ };
\end{minted}

\subsubsection{\texttt{named\_typedef}}

A template class \verb@named_typedef@ should be defined:

\begin{minted}{cpp}
template <typename X, typename T>
struct named_typedef;

template <typename X>
struct named_typedef<X, MetaNamedScoped>
{
	typedef X <NAME>;
};
\end{minted}

The \verb@<NAME>@ expression above should be replaced in the actual specialization generated by the compiler
by the name of the reflected named object. If the generated identifier would clash with a C++
reserved keyword, then a single trailing underscore should be appended to the identifier.
If the generated identifier consists of multiple whitespace separated words then the whitespaces
should be replaced by a single underscore.

For example if a type \verb@__meta_std_thread@
reflects the \verb@std::thread@ class, then the specialization of \verb@named_typedef@
for this metaobject should be following:

\begin{minted}{cpp}
template <typename X>
struct named_typedef<X, __meta_std_thread>
{
	typedef X thread;
};
\end{minted}

if a type \verb@__meta_std@ reflects the \verb@std@ namespace, then the specialization of \verb@named_typedef@
should be:

\begin{minted}{cpp}
template <typename X>
struct named_typedef<X, __meta_std>
{
	typedef X std;
};
\end{minted}

if a type \verb@__meta_@ reflects the global scope (or another anonymous base-level object),
then the specialization of \verb@named_typedef@ should be:

\begin{minted}{cpp}
template <typename X>
struct named_typedef<X, __meta_>
{
	typedef X _;
};
\end{minted}

If the types \verb@__meta_int@ and \verb@__meta_unsigned_long_long_int@ reflect the \verb@int@ and
the \verb@unsigned long long int@ type
respectively, then the matching instantiations of \verb@named_typedef@ should be:

\begin{minted}{cpp}
template <typename X>
struct named_typedef<X, __meta_int>
{
	// note the trailing underscore
	typedef X int_;
};

template <typename X>
struct named_typedef<X, __meta_long_long_unsigned_int>
{
	// note underscores replacing the spaces
	typedef X long_long_unsigned_int;
};
\end{minted}

If the types \verb@__meta_char_const@, \verb@__meta_long_const_ref@, \verb@__meta_int_volatile_ptr@ and \verb@__meta_double_array_5@
reflect \verb@char const@, \verb@long const&@, \verb@int volatile*@ and \verb@double[5]@ respectively,
then the specializations of \verb@named_typeded@ should be:

\begin{minted}{cpp}
template <typename X>
struct named_typedef<X, __meta_char_const>
{
	typedef X char_;
};
template <typename X>
struct named_typedef<X, __meta_long_const_ref>
{
	typedef X long_int;
};
template <typename X>
struct named_typedef<X, __meta_int_volatile_ptr>
{
	typedef X int_;
};
template <typename X>
struct named_typedef<X, __meta_double_array_5>
{
	typedef X double_;
};
\end{minted}

\subsubsection{\texttt{named\_mem\_var}}

A template class \verb@named_mem_var@ should be defined as follows:

\begin{minted}{cpp}
template <typename X, typename T>
struct named_mem_var;

template <typename X>
struct named_mem_var<X, MetaNamedScoped>
{
	X <NAME>;

	template <typename ... P>
	named_mem_var(P&& p)
	 : <NAME>(std::forward<P>(p)...)
	{ };
};
\end{minted}

The \verb@<NAME>@ expression above should be replaced in the actual specialization generated by the compiler
by the name of the reflected named object. If the generated identifier would clash with a C++
reserved keyword, then a single trailing underscore should be appended to the identifier.
If the generated identifier consists of multiple whitespace separated words then the whitespaces
should be replaced by a single underscore.

For example if a type \verb@__meta_std_string@
reflects the \verb@std::string@ typedef, then the specialization of \verb@named_mem_var@
for this metaobject should be following:

\begin{minted}{cpp}
template <typename X>
struct named_mem_var<X, __meta_std_string>
{
	X string;

	template <typename ... P>
	named_mem_var(P&& ... p)
	 : string(std::forward<P>(p)...)
	{ }
};
\end{minted}

If types \verb@__meta_void@ and \verb@_meta_long_double@ reflect the \verb@void@ and \verb@long double@
types respectively, then the matching instantiations of \verb@named_mem_var@ should be:
should be:

\begin{minted}{cpp}
template <typename X>
struct named_mem_var<X, __meta_void>
{
	// note the trailing underscore
	X void_;

	template <typename ... P>
	named_mem_var(P&& ... p)
	 : void_(std::forward<P>(p)...)
	{ }
};

template <typename X>
struct named_mem_var<X, __meta_long_double>
{
	// note underscores replacing the spaces
	typedef X long_double;

	template <typename ... P>
	named_mem_var(P&& ... p)
	 : long_double_(std::forward<P>(p)...)
	{ }
};
\end{minted}

For decorated and qualified types the same rules apply as for \verb@named_typedef@.
If \verb@__meta_std_string_const_ref@ reflects \verb@std::string const&@, then:

\begin{minted}{cpp}
template <typename X>
struct named_typedef<X, __meta_std_string_const_ref>
{
	typedef X string;
};
\end{minted}

