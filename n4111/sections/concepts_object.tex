\subsection{Metaobject}
\label{concept-Metaobject}

\begin{tikzpicture}
\node[concept] (Metaobject) {Metaobject};
\end{tikzpicture}

A \meta{object} is a stateless anonymous type generated by the compiler which
provides metadata reflecting a specific program feature. Each metaobject
should satisfy the following:

Every metaobject should be a nullary metafunction returning itself:

\begin{minted}{cpp}
struct Metaobject
{
	typedef Metaobject type;
};
\end{minted}

The \verb@is_metaobject@ template should return \verb@true_type@.

\begin{minted}{cpp}
template <>
struct is_metaobject<Metaobject>
 : true_type
{ };
\end{minted}

\subsubsection{\texttt{metaobject\_category}}

A template class \verb@metaobject_category@ should be defined in the \verb@std@ namespace
(even if everything else is defined inside of a nested namespace like \verb@std::meta@)
and should inherit from
one of the \hyperref[metaobject-category-tags]{metaobject category tags}, depending on
the actual kind of the metaobject.

\begin{minted}{cpp}
template <typename T>
struct metaobject_category;

template <>
struct metaobject_category<Metaobject>
 : MetaobjectCategory
{ };
\end{minted}

For example if the \verb@__meta_std@ metaobject reflects the \verb@std@ namespace,
then the specialization of \verb@metaobject_category@ should be:

\begin{minted}{cpp}
template <>
struct metaobject_category<__meta_std>
 : namespace_tag
{ };
\end{minted}

\subsubsection{Traits}

The following template classes indicating various properties of a \meta{object}
should be defined and should by default inherit from \verb@false_type@ unless stated
otherwise below:

\verb@has_name@ -- indicates that a \meta{object} is a \meta{Named}:
\begin{minted}{cpp}
template <typename T>
struct has_name
 : false_type
{ };
\end{minted}

\verb@has_scope@ -- indicates that a \meta{object} is a \meta{Scoped}:
\begin{minted}{cpp}
template <typename T>
struct has_scope
 : false_type
{ };
\end{minted}

\verb@is_scope@ -- indicates that a \meta{object} is a \meta{Scope}:
\begin{minted}{cpp}
template <typename T>
struct is_scope
 : false_type
{ };
\end{minted}

\verb@is_class_member@ -- indicates that a \meta{object} is a \meta{ClassMember}:
\begin{minted}{cpp}
template <typename T>
struct is_class_member
 : false_type
{ };
\end{minted}

\verb@has_template@ -- indicates that a \meta{object} is a \meta{Instantiation}:
\begin{minted}{cpp}
template <typename T>
struct has_template
 : false_type
{ };
\end{minted}

\verb@is_template@ -- indicates that a \meta{object} is a \meta{Template}
or \meta{TemplateParameter}:
\begin{minted}{cpp}
template <typename T>
struct is_template
 : false_type
{ };
\end{minted}

