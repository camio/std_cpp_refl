\subsection{Metaobject}
\label{concept-Metaobject}

\begin{tikzpicture}
\node[concept] (Metaobject) {Metaobject};
\end{tikzpicture}

A \meta{object} is a stateless anonymous type generated by the compiler which
provides metadata reflecting a specific program feature. Each metaobject
should satisfy the following:

Every metaobject should be a nullary metafunction returning itself:

\begin{minted}{cpp}
struct Metaobject
{
	typedef Metaobject type;
};
\end{minted}

One possible way how to achieve this is to define {\em basic metaobjects}
as plain types (without any internal structure) and define a class template like:

\begin{minted}{cpp}
template <typename BasicMetaobject>
struct metaobject
{
	typedef metaobject type;
};
\end{minted}

and then, implement the actual \meta{object}s as instantiations of this template.
For example if \verb@__base_meta_int@ is a basic metaobject reflecting the \verb@int@
type then the actual metaobject \verb@__meta_int@ conforming to this concept could 
be defined as:

\begin{minted}{cpp}
typedef metaobject<__base_meta_int> __meta_int;
\end{minted}

Although, this is just one possibility not a requirement of this proposal.

\subsubsection{\texttt{is\_metaobject}}

The \verb@is_metaobject@ template should inherit from \verb@true_type@ for all \meta{object}s,
and inherit from \verb@false_type@ otherwise.

\begin{minted}{cpp}
template <typename T>
struct is_metaobject
 : false_type
{ };

template <>
struct is_metaobject<Metaobject>
 : true_type
{ };
\end{minted}

\subsubsection{\texttt{metaobject\_category}}

A template class \verb@metaobject_category@ should be defined in the \verb@std@ namespace
(even if everything else is defined inside of a nested namespace like \verb@std::meta@)
and should inherit from
one of the \hyperref[metaobject-category-tags]{metaobject category tags}, depending on
the actual kind of the metaobject.

\begin{minted}{cpp}
template <typename T>
struct metaobject_category;

template <>
struct metaobject_category<Metaobject>
 : MetaobjectCategory
{ };
\end{minted}

For example if the \verb@__meta_std@ metaobject reflects the \verb@std@ namespace,
then the specialization of \verb@metaobject_category@ should be:

\begin{minted}{cpp}
template <>
struct metaobject_category<__meta_std>
 : namespace_tag
{ };
\end{minted}

\subsubsection{Comparison}

A template class \verb@equal@ should be defined and should inherit from \verb@true_type@
if a \hyperref[section-Library]{metaobject expression} \verb@Expr1@ {\em evaluates} into
the same metaobject as the metaobject expression \verb@Expr2@ (i.e. into metaobjects
that both reflect the same base-level construct). Otherwise it should inherit from
\verb@false_type@:

\begin{minted}{cpp}
template <typename Expr1, typename Expr2>
struct equal
 : BooleanConstant
{ };
\end{minted}

\subsubsection{Traits}

The following template classes indicating various properties of a \meta{object}
should be defined and should by default inherit from \verb@false_type@ unless stated
otherwise below:

\verb@has_name@ -- indicates that a \meta{object} is a \meta{Named}:
\begin{minted}{cpp}
template <typename T>
struct has_name
 : false_type
{ };
\end{minted}

\verb@has_scope@ -- indicates that a \meta{object} is a \meta{Scoped}:
\begin{minted}{cpp}
template <typename T>
struct has_scope
 : false_type
{ };
\end{minted}

\verb@is_scope@ -- indicates that a \meta{object} is a \meta{Scope}:
\begin{minted}{cpp}
template <typename T>
struct is_scope
 : false_type
{ };
\end{minted}

\verb@is_class_member@ -- indicates that a \meta{object} is a \meta{ClassMember}:
\begin{minted}{cpp}
template <typename T>
struct is_class_member
 : false_type
{ };
\end{minted}

\verb@has_template@ -- indicates that a \meta{object} is a \meta{Instantiation}:
\begin{minted}{cpp}
template <typename T>
struct has_template
 : false_type
{ };
\end{minted}

\verb@is_template@ -- indicates that a \meta{object} is a \meta{Template}
or \meta{TemplateParameter}:
\begin{minted}{cpp}
template <typename T>
struct is_template
 : false_type
{ };
\end{minted}

