\section{Metaobject concept specification}
\label{section-current-Concepts}

We propose that the basic metadata describing a program written
in C++ should be made available through a set of {\em anonymous} types
defined by the compiler and through related functions and template classes.
At the moment these types should describe only the following program
constructs: namespaces\footnote{in a limited form}, types, typedefs,
classes and their data members.

In the future, the set of metaobjects should be extended to reflect also
class inheritance, free functions, class member functions, templates,
template parameters, enumerated values, specifiers, etc.
See appendix~\ref{section-all-Concepts} for more details.

The compiler should generate metadata for the program constructs defined
in the currently processed translation unit, when requested by invoking
the reflection operator. Members of ordered sets (sequences) of metaobjects,
like scope members, parameters of a function, and so on, should be listed
in the order of appearance in the processed source code.

Since we want the metadata to be available at compile-time,
different base-level constructs should be reflected by
{\em statically different} metaobjects and thus by {\em different} types.
For example a metaobject reflecting the global scope namespace should
be a different {\em type} than a metaobject reflecting the \verb@std@
namespace\footnote{this means that they should be distinguishable for
example by the \texttt{std::is\_same} type trait},
a metaobject reflecting the \verb@int@ type should
have a different type then a metaobject reflecting the \verb@double@
type, etc.

This section describes a set of metaobject concepts,
their interfaces\footnote{the requirements that the various metaobjects
need to satisfy in order to be considered models of the individual
concepts},
tag types for metaobject classification and operators providing access to the metaobjects.

Unless stated otherwise, all named templates proposed and described below should
go into the \verb@std::meta@ nested namespace in order to contain reflection-related
definitions and to help avoiding potential name conflicts.

Also note, that in the sections below, the examples use names for concrete
metaobjects, like \verb@__meta_std_string@, etc. This convention
is {\em NOT} part of this proposal. The actual naming of the metaobjects
should be left to the compiler implementations and for all purposes,
from the user's point of view, the metaobjects should be anonymous types.

\input{sections/c_Metaobject.tex}
\input{sections/c_MetaobjectSequence.tex}
\input{sections/c_MetaSpecifier.tex}

\input{sections/c_MetaNamed.tex}
\input{sections/c_MetaTyped.tex}
\input{sections/c_MetaScoped.tex}
\input{sections/c_MetaScope.tex}
\input{sections/c_MetaAlias.tex}

\input{sections/c_MetaGlobalScope.tex}
