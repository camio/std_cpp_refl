\subsection{MetaAlias}
\label{concept-MetaAlias}

\meta{Alias} is a \meta{Type} or \meta{Namespace} and possibly a \meta{Template}
reflecting an alias of a type (\verb@typedef@), template or namespace.

In addition to the requirements inherited from \meta{Type}, \meta{Namespace}
or \meta{Template} the following is required:

The \verb@is_alias@ template class specialization for a \meta{Alias} should
inherit from \verb@true_type@:

\begin{minted}{cpp}
template <>
struct is_aliased<MetaAlias>
 : true_type
{ };
\end{minted}

\subsubsection{\texttt{aliased}}

A template class called \verb@aliased@ should be defined and should inherit
\begin{itemize}
\item from a \meta{Type}
reflecting the aliased type of the alias in case of a type alias, or
\item from a \meta{Namespace}
reflecting the aliased namespace in case of a namespace alias.
\end{itemize}

\begin{minted}{cpp}
template <typename T>
struct aliased;

template <>
struct aliased<MetaAlias>
 : MetaNamedScoped
{ };
\end{minted}

For example if \verb@__meta_std_string@ is a \meta{Alias} reflecting the \verb@std::string@
typedef and \verb@__meta_std_basic_string_char@ is the \meta{Type} that reflects
the \verb@std::basic_string<char>@ type, and \verb@std::string@ is defined as:

\begin{minted}{cpp}
namespace std {
typedef basic_string<char> string;
}
\end{minted}

then the specialization of \verb@aliased @ for \verb@__meta_std_string@ should be following:

\begin{minted}{cpp}
template <>
struct aliased<__meta_std_string>
 : __meta_std_basic_string_char
{ };
\end{minted}

