\subsection{Metaobject}
\label{concept-Metaobject}

A \meta{object} is a stateless anonymous type generated by the compiler which
provides metadata reflecting a specific program feature. Each metaobject
should satisfy the following:

Every metaobject should be a nullary metafunction returning itself.

\begin{minted}{cpp}
struct Metaobject
{
	typedef Metaobject type;

	constexpr Metaobject(void) noexcept;
};
\end{minted}

One possible way how to achieve this is to define {\em basic metaobjects}
as plain types (without any internal structure) and define a class template like:

\begin{minted}{cpp}
template <typename BasicMetaobject>
struct metaobject
{
	typedef metaobject type;
};
\end{minted}

and then, implement the actual \meta{object}s as instantiations of this template.
For example if \verb@__base_meta_int@ is a basic metaobject reflecting the \verb@int@
type then the actual metaobject \verb@__meta_int@ conforming to this concept could 
be defined as:

\begin{minted}{cpp}
typedef metaobject<__base_meta_int> __meta_int;
\end{minted}

Although this is just one possibility not a requirement of this proposal.

\subsubsection{\texttt{is\_metaobject}}

The \verb@is_metaobject@ template should inherit from \verb@true_type@ for all \meta{object}s,
and inherit from \verb@false_type@ otherwise.

\begin{minted}{cpp}
template <typename T>
struct is_metaobject
 : false_type
{ };

template <>
struct is_metaobject<Metaobject>
 : true_type
{ };
\end{minted}

\subsubsection{\texttt{category}}

A template class \verb@category@ should be defined and should inherit from
one of the \hyperref[metaobject-category-tags]{metaobject category tags}, depending on
the actual kind of the metaobject.

\begin{minted}{cpp}
template <typename T>
struct category;

template <>
struct category<Metaobject>
 : MetaobjectCategory
{ };
\end{minted}

For example if the \verb@__meta_std@ metaobject reflects the \verb@std@ namespace,
then the specialization of \verb@category@ should be:

\begin{minted}{cpp}
template <>
struct category<__meta_std>
 : namespace_tag
{ };
\end{minted}

\subsubsection{Traits}

The following template classes indicating various properties of a \meta{object}
should be defined and should by default inherit from \verb@false_type@ unless stated
otherwise below:

\verb@has_name@ -- indicates that a \meta{object} is a \meta{Named}:
\begin{minted}{cpp}
template <typename T>
struct has_name
 : false_type
{ };
\end{minted}

\verb@has_scope@ -- indicates that a \meta{object} is a \meta{Scoped}:
\begin{minted}{cpp}
template <typename T>
struct has_scope
 : false_type
{ };
\end{minted}

\verb@is_scope@ -- indicates that a \meta{object} is a \meta{Scope}:
\begin{minted}{cpp}
template <typename T>
struct is_scope
 : false_type
{ };
\end{minted}

\verb@is_alias@ -- indicates that a \meta{object} is a \meta{Alias}:
\begin{minted}{cpp}
template <typename T>
struct is_alias
 : false_type
{ };
\end{minted}

\verb@has_position@ -- indicates that a \meta{object} is a \meta{Positional}:
\begin{minted}{cpp}
template <typename T>
struct has_position
 : false_type
{ };
\end{minted}

\verb@is_class_member@ -- indicates that a \meta{object} is a \meta{ClassMember}:
\begin{minted}{cpp}
template <typename T>
struct is_class_member
 : false_type
{ };
\end{minted}

\subsubsection{\texttt{source\_file}}

A template class \verb@source_file@ should be defined and should return the
path to the source file where the base-level construct reflected by a
metaobject is defined (similar to what the preprocessor macro \verb@__FILE__@
expands to).

\begin{minted}{cpp}
template <typename T>
struct source_file;

template <>
struct source_file<MetaObject>
 : StringConstant
{ };
\end{minted}

For base-level constructs like namespaces which don't have a single specific
declaration, an empty string should be returned.

\subsubsection{\texttt{source\_line}}

A template class \verb@source_line@ should be defined and should return the (positive)
line number in the source file where the base-level construct reflected by a
metaobject is defined (similar to what the preprocessor symbol \verb@__LINE__@
expands to).

\begin{minted}{cpp}
template <typename T>
struct source_line;

template <>
struct source_line<MetaObject>
 : integral_constant<unsigned, Line>
{ };
\end{minted}

For base-level constructs like namespaces which don't have a single specific
declaration, line number zero should be returned.

\textbf{Note:} \verb@source_file@ and \verb@source_line@, could be
replaced with the source-code information capture as proposed in N4129.

