\subsection{Reflection}

The metaobjects can be provided either via a set of overloaded
functions or template classes similar to \verb@type_traits@ defined
in the \verb@std@ namespace or by a new operator.
Both of these approaches have advantages and disadvantages
and both also depend on how the logical concepts are transformed to
the C++ types generated by the compiler.

Another important aspect is, whether the metaobjects are returned
as types or as objects. This is closely tied to how the logical concepts
are transformed to concrete C++ which determines how the metaobjects
are used.

\subsubsection{Reflection functions}

In this approach at least two functions should be defined
in the \verb@std@ namespace:

\begin{itemize}
	\item{{\em unspecified-type} \verb@ reflected_global_scope(void);@} (or
	alternatively \verb@mirrored_global_scope()@)
	This function should return a type conforming to the {\metaobject{GlobalScope}}
	concept, reflecting the global scope.
	The real type of the result is not defined by the standard, i.e. it is an implementation detail. 
	If the caller needs to store the result of this function the \verb@auto@ type
	specifier should always be used.

	\item{\verb@template <typename Type>@\\
	{\em unspecified-type} \verb@ reflected(void);@} (or alternativelly \verb@mirrored<Type>()@)
	This function should return a type conforming to the {\metaobject{Type}}
	concept, reflecting the \verb@Type@ passed as template argument to this function.
	The real type of the result is not defined by the standard, i.e. it is an implementation detail. 
	If the caller needs to store the result of this function the \verb@auto@ type
	specifier should always be used.
\end{itemize}

Several other similar functions could be added to the list above
for reflection of templates, enumerated values, etc. without defining
new rules for what regular function and template parameters can be.
The advantages of using reflection functions are following:

\begin{itemize}
	\item No need to add a new keyword to the language.

	\item Reduced chance of breaking existing code. The \verb@reflected_global_scope()@
	and \verb@reflected<Type>()@ (nor \verb@mirrored_global_scope()@ and 
	\verb@mirrored<Type>()@) functions are currently not defined in the \verb@std@
	namespace and therefore should not clash with existing user code.
\end{itemize}

This approach has the following disadvantages:

\begin{itemize}
	\item Less direct reflection. Using this approach it is not possible
	(at least without adding new rules for possible values of template
	and function parameters) to reflect constructors, overloaded functions
	and some other things.
\end{itemize}

\subsubsection{Reflection operator}

In this approach a new operator (we suggest the name) \verb@mirrored(@{\em param}\verb@)@
(or alternativelly \verb@reflected(@{\em param}\verb@)@for additional alternatives see below)
should be added.
Depending on {\em param} -- which could be a type name, namespace name,
template name, overloaded function name, enumerated value name, etc. -- the operator should
return a {\metaobject{Named}} metaobject reflecting the specified feature.
If the parameter is ommited a type conforming to the {\metaobject{GlobalScope}} metaobject
concept should be returned.
The exact types returned by the operators should be implementation details.
For example:

\begin{minted}{cpp}
//
typedef integral_constant<size_t, 0> _0;
typedef integral_constant<size_t, 1> _1;
typedef integral_constant<size_t, 2> _2;
typedef integral_constant<size_t, 3> _3;
//
// reflect the global scope
// meta_gs conforms to the GlobalScope concept
mirrored() meta_gs;

static_assert(
	meta_gs.member_count() > 0,
	"The global scope has no members!"
);

static_assert(
	meta_gs.base_name().size() == 0,
	"Name of the global scope is not an empty string!"
);


//
// reflect the std namespace
// meta_std conforms to the Namespace concept
mirrored(std) meta_std;

static_assert(
	is_same<
		meta_gs,
		decltype(meta_std.scope())
	>::value,
	"Namespace std is not in the global scope!"
);

static_assert(
	meta_std.base_name().size() == 3,
	"Name of the std namespace does not have 3 characters!"
);

static_assert(
	meta_std.base_name().at(_0) == 's',
	"Name of the std namespace does not start with 's'!"
);

assert(strcmp(meta_std.base_name().c_str(), "std") == 0);


//
// reflect the errno variable
// meta_errno conforms to the Variable concept
mirrored(errno) meta_errno;

//
// reflect the int type
// meta_int conforms to the Type concept
mirrored(int) meta_int;

//
// reflect the std::string typedef
// meta_std_string conforms to the Typedef concept
mirrored(std::string) meta_std_string;

//
// reflect the std::map template
// meta_std_map conforms to the Template
// and Class concepts
mirrored(std::map) meta_std_map;

//
// reflect the std::map<int, std::string> type
// meta_std_map_int_std_string conforms to Class
// and Instantiation concepts
mirrored(std::map<int, std::string>)
	meta_std_map_int_std_string;

//
// reflect the std::string's (overloaded) constructors
// meta_std_string_string conforms to
// the OverloadedFunction concept and the individual
// overloads that it allows to traverse conform
// to the Constructor concept
mirrored(std::string::string) meta_std_string_string;

//
// reflect ths std::string's copy constructor
// meta_std_string_string_copy conforms to
// the Constructor concept
mirrored(std::string::string(const std::string&))
	meta_std_string_string_copy;
	

//
// reflect the std::swap overloaded free function
// meta_std_swap conforms to OverloadedFunction
mirrored(std::swap) meta_std_swap;

// reflect the (local) variable i
// meta_i conforms to Variable
int i = 42;
mirrored(i) meta_i;

\end{minted}

Alternativelly the \verb@mirrored@ keyword could return a value (instead of a type)
and would be used as in the following examples:

\begin{minted}{cpp}
// overloaded constructors of std::string
auto meta_std_string_string = mirrored(std::string::string);
// the first constructor
auto meta_std_string_string_0 = meta_std_string_string.overloads().at(_0);
\end{minted}

Using a new operator has the following advantages:

\begin{itemize}
	\item More direct reflection. Even features that
	could not be reflected by using a (templated) function
	could be reflected with an operator.

	\item More consistent reflection. Everything is reflected
	with a single operator.
\end{itemize}

and these disadvantages:

\begin{itemize}
	\item Requires a new keyword or the usage of an existing
	keyword in a new context or the usage of a character
	sequence that is currently invalid.

	\item Increased risk of breaking existing code. Could
	be resolved by using an existing operator like \verb@%@,
	\verb@|@, etc.,
	or the use of a currently invalid character or character
	sequence like \verb'@', \verb@$@ or the usage of a new set
	of quotations like \verb@`@ (backtick character).
	For example:
	\begin{minted}{cpp}
	// instead of:
	auto meta_std_string = mirrored(std::string);
	// use
	auto meta_std_string = %std::string;
	// or 
	auto meta_std_string = |std::string;
	// or
	auto meta_std_string = @std::string;
	// or
	auto meta_std_string = `std::string`;
	// or
	auto meta_std_string = [[std::string]];
	\end{minted}
	The problem with these may be the reflection
	of the global scope, which when using some of
	the above would result in awkward expressions
	like:
	\begin{minted}{cpp}
	// instead of
	auto meta_gs = mirrored();
	// use
	auto meta_gs = %;
	auto meta_gs = |;
	auto meta_gs = @;
	// or 
	auto meta_gs = ``; 
	auto meta_gs = [[]];
	\end{minted}
\end{itemize}
