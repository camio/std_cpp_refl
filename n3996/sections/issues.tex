\section{Unresolved Issues}
\label{section-issues}

\begin{itemize}
	\item {\em Something similar to source contexts from D3972:} Should {\metaobject{Metaobject}} contain information
	about the source file, line and possibly line column or function name where the base-level construct
	reflected by the {\metaobject{Metaobject}} was defined ?

	\item {\em Normalization of names returned by \verb@Named::base_name()@\\and \verb@NamedScoped::full_name()@:}
	The strings returned by the \verb@base_name@ and \verb@full_name@ functions should be
	implementation-independent and the same on every platform/compiler.

	\item {\em The syntax of annotation of base-level program constructs with tags and relations}.

	\item {\em The reflection of C++11/14 features not covered by this proposal}.

	\item {\em The use of "generalized attributes" for annotations}. Would it be possible
	(and wise) to use the generalized attributes (from N2761) to annotate program features
	as suggested in subsection \ref{annotations-and-relations}?

	\item {\em Explicit specification of what should be reflected}. It might be useful to have
	the ability to explicitly specify either what to reflect or what to hide from reflection.
	For example the "whitelisting" (explicitly specifying of what should be reflected) of namespace
	or class members could simplify reflective meta-algorithms so that they would not have
	to implement complicated filters when traversing scope members, to hide implementation details and
	to improve compilation times. It is important that this functionality is decoupled from the
	scope member declarations, since it would allow applications to cherry-pick what should be
	reflected even in third-party libraries.
	This might be a separate feature, but it also could be merged with the tagging functionality.
	Applications could tag program constructs in which they are interested and apply a simple
	filter based on the tag(s) when traversing scope members.
\end{itemize}
