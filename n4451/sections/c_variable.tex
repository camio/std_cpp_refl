\subsection{MetaVariable}
\label{concept-MetaVariable}

\begin{tikzpicture}
\node [concept] (Metaobject) {Metaobject};
\node [concept] (MetaNamed)[above right=of Metaobject] {MetaNamed}
	edge [inheritance, bend right] (Metaobject);
\node [concept] (MetaScoped)[below right=of Metaobject] {MetaScoped}
	edge [inheritance, bend left] (Metaobject);
\node [concept] (MetaNamedScoped)[below right=of MetaNamed, above right=of MetaScoped] {MetaNamedScoped}
	edge [inheritance, bend right] (MetaNamed)
	edge [inheritance, bend left] (MetaScoped);
\node [concept] (MetaVariable)[above right=of MetaNamedScoped] {MetaVariable}
	edge [inheritance, bend right] (MetaNamedScoped);
\end{tikzpicture}

\meta{Variable} is a \meta{NamedScoped} reflecting a variable.

In addition to the requirements inherited from \meta{NamedScoped}, the following must
be satisfied:

The \verb@metaobject_category@ template class specialization for a \meta{Variable} should
inherit from \verb@variable_tag@:

\begin{minted}{cpp}
template <>
struct metaobject_category<MetaVariable>
 : variable_tag
{ };
\end{minted}

\subsubsection{\texttt{storage\_specifier}}

A template class \verb@storage_specifier@ should be added and should
inherit from a \meta{Specifier} reflecting a storage class specifier:

\begin{minted}{cpp}
template <typename T>
struct storage_specifier;

template <>
struct storage_specifier<MetaVariable>
 : MetaSpecifier
{ };
\end{minted}

\subsubsection{\texttt{type}}

A template class \verb@type@ should be added and should inherit
from a \meta{Type} reflecting the type of the variable:

\begin{minted}{cpp}
template <typename T>
struct type;

template <>
struct type<MetaVariable>
 : MetaType
{ };
\end{minted}

\subsubsection{\texttt{pointer}}

If the reflected variable is a namespace-level variable, then a template
class \verb@pointer@ should be implemented as follows:

\begin{minted}{cpp}
template <typename T>
struct pointer;

template <>
struct pointer<MetaVariable>
{
	typedef typename original_type<type<MetaVariable>>::type* type;

	static type get(void);
};
\end{minted}

The static member function \verb@get@ should return the address of the reflected variable.

If the reflected variable is a class member variable (i.e. if the \meta{Variable}
is also a \meta{ClassMember}), then the \verb@pointer@ template class should be
defined as follows:

\begin{minted}{cpp}

template <>
struct pointer<MetaVariable>
{
	typedef typename original_type<type<MetaVariable>>::type
		_mv_t;
	typedef typename original_type<type<scope<MetaVariable>>>::type
		_cls_t;

	typedef _mv_t _cls_t::* type;

	static type get(void);
};

\end{minted}

The static member function \verb@get@ should return a data member pointer to
the reflected member variable. The \verb@_mv_t@ and \verb@_cls_t@ typedefs
are implementation details and are not a part of this specification.
