\section{Frequently asked questions}

\subsection{Why metaobjects, why not reflect directly with type traits?}
\label{faq-why-metaobjects}

\textbf{Q:} {\em Why should we bother with defining a set of metaobject concepts,
let the compiler generate models of these concepts and use those to obtain
the metadata? Why not just extend the existing type traits?}

\textbf{A:} The most important reasons are the \hyperref[design-completeness]{completeness} and the scope of reflection.
Type traits\footnote{As they are defined now.} work just with types.
A reflection facility should however provide much more metadata.
It should be able to reflect namespaces, functions, constructors,
class inheritance, templates, specifiers, variables, etc.

Without drastically changing the rules specifying what can or cannot be a template
parameter, we cannot reflect C++'s second-class declarations like namespaces.

This is also connected with the usability of reflection in metaprograms.
Using types to reflect various base-level declarations, allows to
pass a representation of a namespace, a constructor, aspecifier or a parameter,
around various \say{subroutines} of a metaprogram as a parameter or a return value.

In order to achieve this by other means it would be necessary to make namespaces,
etc. first-class objects or at least to allow them to become template arguments.

So with type-based metaobjects we can do for example the following:

\begin{minted}{cpp}
template <typename Metaobject>
void foo(void)
{
	// do something terribly useful
}

foo<reflexpr(int)>(); // works
foo<reflexpr(std)>(); // works
foo<reflexpr(std::string)>(); // works
foo<reflexpr(std::string::size_type)>(); // works
foo<reflexpr(std::size_t)>(); // works and is different from the above
foo<reflexpr(std::pair)>(); // works
foo<reflexpr(std::sqrt)>(); // works
foo<reflexpr(static)>(); // works
\end{minted}

meanwhile without metaobjects:

\begin{minted}{cpp}
template <something Param>
void foo(void)
{
	// do something terribly useful, if possible
}

foo<int>(); // works
foo<std>(); // error?
foo<std::string>(); // works
foo<std::string::size_type>(); // works
foo<std::size_t>(); // works but same as the above
foo_tpl<std::pair>(); // works (if there are two versions of foo)
foo<std::sqrt>(); // error?
foo<static>(); // error?
\end{minted}

\subsection{OK, but why not reflect directly with several different operators?}

\textbf{Q:} {\em Alright, we partially agree with the reasoning in the
\hyperref[faq-why-metaobjects]{previous question}, but why don't we use several
different operators to get the various pieces of metadata (like declaration names,
types, scopes, etc.) directly, skipping the metaobjects?
For example we already have \verb@decltype(expr)@ so why not add,
\verb@declname(expr)@ or \verb@declscope(expr)@, etc.}

\textbf{A:} The main reason is that there are many base-level declarations
with various properties which we want to reflect and having a separate
operator for every one of them\footnote{There may be even several dozen.},
will require many new reserved keywords which can break existing code.

And still, what would the operator reflecting for example a scope return?
In case of class scopes it could return a type, but what if we are asking
about the scope of a global-scope or namespace-level declaration? We would
either end up with something like the proposed metaobjects,
or we would have to make some other (not type-based) representation of any
possible scope.
In case of the latter we would loose the ability to pass the representation
of the scope as parameters to metaprograms.

The same applies to every other operation returning an expression which does
not have first-class identity in base-level C++.

It is possible that, the templates implementing the metaobject operations
will internally use compiler built-ins\footnote{Just like some of the type traits
are implemented.}, but these can use compiler-specific reserved keywords
and they will all operate on the metaobjects.

\subsection{Creating a separate type for each metaobject is so heavyweight.}

\textbf{Q:} {\em Isn't the creation of a new type for each metaobject too
heavyweight? Won't it lead to unacceptable increases in the memory footprint
and compilation times?}

\textbf{A:} This might have been a problem if the metaobjects were regular
types and if the implementation was too coarse-grained or too eager.

For example if upon the invocation of \verb@reflexpr(std::string)@, the representations
of all the metadata related to the \verb@std::string@ type\footnote{Like
the compile-time representation of its name, the metaobjects reflecting its scope
or its members.} were generated immediately.

This is however {\em not} the case.

The metaobjects need to be types just enough so that they can be used
as template arguments\footnote{Similar to the \texttt{void} type}.
They don't need to have any name, scope, implicitly generated constructors,
destructors, assignment operators, virtual method tables, run-time type information,
etc. All they need to have is a unique identity and their internal representations
need to point to the internal representations of the declarations\footnote
{Which the compiler needs to maintain anyway, regardless of reflection.}
which they reflect.

Also our proposal allows very fine granularity. The result of \verb@reflexpr@
can be a very lightweight type, as we just described and the individual
\say{attributes} like the name, scope, members, specifiers, etc. related
to the metaobject are materialized only when requested by one of the operations
defined for that particular metaobject concept, like \verb@get_name@,
\verb@get_scope@, \verb@get_data_members@, etc.

\subsection{Creating a separate type for each string is so heavyweight.}

\textbf{Q:} {\em Isn't the creation of a new type for each string returned
for example from the \verb@get_name@ operation too heavyweight?
Won't that lead to unacceptable increases in the memory footprint
and compilation times?}

\textbf{A:} The answer is that we {\em do not} insist on creating a separate
type for each string returned by reflection. What we insist on is that we
should have the ability to reason about and manipulate the strings at compile-time.
A static, \verb@constexpr@-initialized, zero-terminated array of \verb@char@s
gives us this ability.

So for example the implementation of the \verb@get_name@ operation should
{\em be equivalent} to the following:

\begin{minted}[tabsize=4]{cpp}
template <Named T>
struct get_name
{
	typedef const char value_type[N+1];
	static constexpr const char value[N+1] = {...,'\0'};
};
\end{minted}

Some members of the committee suggested that for example the
\texttt{basic\_string\_constant} from N4236 or some other compile-time
string representation which eventually makes it to the standard could
be used to implement the \verb@get_name@ operation,
but this in just an option not a requirement for our part.
We trust in the ability of the compiler vendors to pick and
implement the best option and to use all the tricks at their disposal
to make expressions like;

\begin{minted}{cpp}
std::string(std::meta::get_name_v<reflexpr(std::pair)>);
\end{minted}

as efficient as possible.

\subsection{There's already a type trait for that!}

\textbf{Q:} {\em Why do you introduce a metaobject trait like
\verb@std::meta::is_class<Metaobject>@  when there already are type traits like
\verb@std::is_class<T>@?}

\textbf{A:} The reason is consistency.
While it is true that there are a few metaobject traits, which indicate the
same thing as already existing type traits, omitting the metaobject trait
in favor of the type trait would break consistency and make the interface less generic.

For example the following is much more consistent and nicer,

\begin{minted}{cpp}
template <typename Metaobject>
void foo(void)
{
	if(std::meta::is_class_v<Metaobject>) { ... }
	else if(std::meta::is_typedef_v<Metaobject>) { ... }
	else if(std::meta::is_type_v<Metaobject>) { ... }
	else if(std::meta::is_namespace_v<Metaobject>) { ... }
	else if(std::meta::is_function_v<Metaobject>) { ... }
}
\end{minted}

than,

\begin{minted}{cpp}
template <typename T, typename Metaobject>
void foo(void)
{
	if(std::is_class_v<T>) { ... }
	else if(meta::is_typedef_v<Metaobject>) { ... }
	else if(meta::is_type_v<Metaobject>) { ... }
	else if(meta::is_namespace_v<Metaobject>) { ... }
	else if(meta::is_function_v<Metaobject>) { ... }
}
\end{minted}

or even,

\begin{minted}{cpp}
template <typename Metaobject>
void foo(void)
{
	if(std::is_class_v<get_original_type_t<Metaobject>>) { ... }
	else if(meta::is_typedef_v<Metaobject>) { ... }
	else if(meta::is_type_v<Metaobject>) { ... }
	else if(meta::is_namespace_v<Metaobject>) { ... }
	else if(meta::is_function_v<Metaobject>) { ... }
}
\end{minted}

Even more important is the problem with breaking genericity:

\begin{minted}{cpp}
template <typename Metaobject, template <class> class Trait>
void bar(void)
{
	if(Trait<Metaobject>::value) { ... }
	else { ... }
}

bar<reflexpr(std), std::meta::is_namespace>(); // works
bar<reflexpr(static), std::meta::is_specifier>(); // works
bar<reflexpr(std::string), std::meta::is_class>(); // works
bar<reflexpr(std::string), std::is_class>(); // error!
\end{minted}


In C++ there are many examples of various expressions doing the same thing,
this is just one of them.
Having several options is not a bad thing, pick the one most appropriate for your
particular use-case.


\subsection{There's already another expression for that!}

\textbf{Q:} {\em There are situations where you can do something much more
easily without reflection than with it, like \verb@&variable@ vs.
\verb@meta::get_pointer_v<reflexpr(variable)>@ or\\\verb@decltype(var)@ vs.
\verb@meta::get_original_type_t<meta::get_type_t<reflexpr(var)>>@, etc.}

\textbf{A:} Of course there are! There are also situations where the decision
that you want to get a pointer to or a to get the type of a (reflected) variable
can be separated from the actual site where you access (reflect) the variable by
several layers of metaprogram templates. Both use-cases are valid and
again, you should pick the most appropriate option for your situation.

\subsection{Why are the metaobjects anonymous?}

\textbf{Q:} {\em Why should the metaobjects be anonymous types as opposed to
types with well defined and standardized names or concrete template classes, (possibly with some
special kind of parameter accepting different arguments than types and constants)?}

\textbf{A:} We wanted to avoid defining a specific naming convention, because it would
be difficult to do so and very probably not user friendly (see C++ name mangling). There
already are precedents for anonymous types -- for example C++ {\em lambdas}.

Another option would be to define a concrete set of template classes like:

\begin{minted}{cpp}
namespace std {

template <typename T>
class meta_type /* Model of MetaType */
{ };

}
\end{minted}

which could work with types, classes, etc., but would not work with namespaces,
constructors, etc. (see also the Q/A above):

\begin{minted}{cpp}
namespace std {

template <something X> // problem
class meta_constructor /* Model of MetaConstructor */
{ };

template <something X> // problem
class meta_namespace /* Model of MetaNamespace */
{ };

}

typedef std::meta_namespace<std> meta_std; // problem
\end{minted}

Instead of this, the metaobjects are anonymous and their (internal) identification
is left to the compiler. From the user's point of view, the metaobject can be distinguished
by the means of the metaobject traits and tags.

\subsection{Reflection violating access restriction to class members?}

\textbf{Q:} {\em Why do you allow reflection to bypass the class member access
restrictions? This is like giving people nuclear weapons. I don't want people
to have nuclear weapons [sic].}

\textbf{A:}
This is a valid point, but there are several different ways to break access restrictions
if the programmer wants to and we feel that restricting reflection only to public
class members would severely limit its usefulness. Having said that we also
try to design the interface to indicate to the users that they are breaking
encapsulation.

\subsection{Why do we need typedef reflection?}

\textbf{Q:} {\em Why is it necessary to distinguish between types and typedefs
or type aliases on the meta-level when they are not distinguishable on the
base-level? Or why do we need to reflect on syntax rather than just on semantics?}

\textbf{A:}
TODO

\subsection{Why \meta{ObjectSequence}s? Why not replace them with typelists?}

\textbf{Q:} {\em Why do you define the \meta{ObjectSequence} concept and its
operations? There are type-lists proposed for the inclusion into the standard,
why not use those?}

\textbf{A:} The reason why we use \meta{ObjectSequence}s is efficiency.
Operations like \verb@get_data_members@ currently return metaobjects, i.e.
very lightweight types representing a whole set of metaobjects, without actually
instantiating the elements eagerly.

So for example if we wanted the reflection of the first\footnote{zero-th}
data member of a class having hundreds of member we could do:

\begin{minted}{cpp}
get_element_t<get_data_members_t<reflexpr(my_class)>, 0>;
\end{minted}

This operation would involve the creation of two metaobjects:
\begin{enumerate}
	\item the \meta{ObjectSequence} and
	\item the \meta{DataMember} reflecting the first data member.
\end{enumerate}

On the other hand if this operation returned a typelist of metaobjects,
then all metaobjects would have to be generated, even if most of them
were not used afterwards.

What we can do is to add an operation converting a \meta{ObjectSequence}
into a type-list on demand.

