\section{The unpredictable future}

In this section we would like to discuss some of the possiblities of future
evolution of reflection.

\subsection{Reversing reflection}

The \verb@reflexpr@ operator allows to obtain the meta-level representation
of a base-level declaration. But what if we wanted to do the opposite: to
get back the original declaration from a metaobject?

This of course would make sense only for a subset of metaobjects, so let's
define a new concept like \meta{Revertible}.

One way to achieve this would be to extend the \verb@reflexpr@
operator. In case that the operand of \verb@reflexpr@ is a \meta{Revertible}
it should \say{return} the original declaration, for other metaobjects the behavior
would be undefined.

Let's look at some possible use cases for this feature.
The most trivial one is to replace the \texttt{get\_original\_type}
template from the interface of \meta{Type}:

\begin{minted}{cpp}
using MT = reflexpr(int);

// ... lots of other code here ...

// Now we arrived to a point where we need
// to get the base-level type reflected by `MT`.

// Instead of using get_original_type ...
using T = get_original_type_t<MT>;

// we could do:
static_assert(meta::is_revertible_v<MT> && meta::is_type_v<MT>, "");
using T = reflexpr(MT);
static_assert(is_same_v<T, int>, "");

\end{minted}

But that's far from being the only use case. If we could get back to
the original namespace or variable;

\begin{minted}{cpp}

namespace foo {
std::string str;

void bar(const std::string&);
} // namespace foo

using MV = reflexpr(foo::str); // Meta-Variable

// ... lots of code here ...
// using namespace foo;
using namespace reflexpr(get_scope_t<MV>);

// [foo::]bar(foo::str);
bar(reflexpr(MV));

\end{minted}

or back to the original function;

\begin{minted}{cpp}

namespace foo {
void bar(const std::string&);
} // namespace foo

using MF = reflexpr(foo::bar); // Meta-Function

// ... lots of code here ...
// foo::bar("hello");
reflexpr(MF)("hello");

\end{minted}

or back to the original class data member;

\begin{minted}{cpp}

struct my_struct
{
	int i;
	float f;
};

// Meta-DataMember
using MDM = get_element_t<get_data_members_t<reflexpr(foo::bar)>, 0>;

my_struct x {123, 45.67f};

assert(x.i == 123);
// x.i = 234;
x.reflexpr(MDM) = 234;
assert(x.i == 234);

\end{minted}

or go back to the original template;

\begin{minted}{cpp}

// Meta-Template
using MTpl = reflexpr(std::pair);

// std::pair<int, std::string> p;
reflexpr(MTpl)<int, std::string> p{10, "Hi!"};

\end{minted}

etc.
Combined with the fact that all metaobjects are first-class
entities would make this a very powerful feature, which would essentially
allow to sort or reify all reflectable declarations, even those which are
second-class without actually reifying them at the base-level\footnote{
At the cost of the round-trip through the meta-level.}.
