\section{Introduction}

This paper accompanies the P0194Rx papers which we want to keep brief, technical
and to the point and which will eventually result in the final wording to be
included into the standard if this proposal is accepted.

We are writing this paper with several goals in mind:

\begin{itemize}
\item To define and explain the reflection-related terminology.
\item To keep a written record of the rationale behind the design of the
proposed static reflection facility.
\item To keep the answers to the frequently asked questions about
the decisions we've made in this proposal in one place so that we can avoid
having to write them over and over from scratch in various discussions\footnote{
Also to help us remember what the answers were.}.
\item To enumerate and describe the use cases for the various features
which we included in the proposal.
\item To provide concrete examples of usage.
\item To discuss the possibilities of the evolution of reflection in the future.
\end{itemize}

\subsection{Terminology}

In order to avoid confusion about terminology, this section provides definitions
for several important terms used throughout the text of the paper and
explains what we mean when using them in the context of this paper.

\subsubsection{Base-level, meta-level}
\label{term-base-meta-level}

When speaking generally, the {\em meta-level} is some higher level of abstraction
conceptually describing a lower, {\em base-level} which is the primary subject
of our endeavors.

In the context of this paper the base-level is the structure of a C++ program.
The meta-level is an abstraction partially describing that structure,
mainly the declarations of the program.

\subsubsection{Metadata}
\label{term-metadata}

{\em Metadata} is generally a piece of data conceptually describing some other,
{\em primary} data.

In the context of this paper, metadata is data providing information
about the base-level structure of a program.
{\em Static} metadata is metadata which can be manipulated or reasoned
about at compile-time by the compiler.

The metadata itself can have its own structure.
For example metadata describing the base-level declaration of a class 
from a C++ program includes, the name of that class, its scope, list of base classes
and members, source location information, etc.

\subsubsection{Metaprogramming}

{\em Metaprogramming} is a kind of programming with the ability to treat and
manipulate other programs as data, so both the input and the output of
a metaprogram is usually a program. The language in which metaprograms
are written is called the {\em metalanguage} and it can be a different or the
same language as the one used to write the primary program.

C++ metaprogramming can be done both in an external language\footnote{For example a
C++ code generator written in Python or Bash.}, in a C++ compiler plug-in,
or in C++ itself. 

When done directly in C++, metaprogramming usually takes the form of a
{\em source code generator}\footnote{Like Qt's MOC.}, or the form of {\em preprocessor}
or {\em template} metaprogramming.

In template metaprogramming we use C++'s type system
as a standalone functional programming language \say{interpreted} by a C++
compiler, with \say{variables} being
represented by types (or compile-time constants),
\say{data structures} by instantiations of templates,
\say{subroutines} by class templates or template aliases, and
algorithms or \say{programs} by compositions of the above.

Unless stated otherwise when we say \say{metaprogramming} in the following text,
we mean template metaprogramming.

\subsubsection{Reflection}

In the context of computer science
the term {\em reflection} refers to the ability of a program to examine
and possibly modify its own structure and/or behavior.

When combined with metaprogramming, this can include modification of the existing
or the definition of new data structures, doing changes to algorithms or changing the way
a program code is interpreted\footnote{Mostly in interpreted languages.}.

For the purpose of this paper reflection is the process of obtaining metadata.
In the future the meaning can be expanded to include modification of the program
in ways exceeding the capabilities of current template metaprogramming.

\subsubsection{First class object, second class object}
\label{term-first-class}

Also known as first class -- {\em citizen}, {\em type}, {\em entity} or {\em value},
in the context of programming language design is an entity that satisfies
the following:

\begin{itemize}
	\item{Can be stored in a named variable or a data structure.}
	\item{Can be passed as an argument to a subroutine.}
	\item{Can be returned as a result of a subroutine.}
	\item{Has an intrinsic identity making the entity unique and distinguishable.}
\end{itemize}

Since this paper deals with compile-time static reflection and its use
in template metaprogramming, we will be talking about first- or second- class
citizens in this regard. 
For the purpose of this paper a first-class object is something that
we can distinguish and reason about at compile-time and what can be passed around
as \say{data} in metaprograms -- something that can be a template parameter.

This means that a type or a template is for our purposes a first class object:

\begin{minted}{cpp}
struct value_a { };
struct value_b { };

template <typename Param> struct identity
{
	typedef Param result;
};

// are equality comparable and they are distinguishable
assert(!std::is_same_v<value_a, value_b>, "");
assert(!std::is_same_v<identity<value_a>, identity<value_b>>, "");

// they can be stored in named "variables" ...
using x = value_a;

// ... while maintaining their identity
assert(std::is_same_v<value_a, x>, "");

// they can be passed as parameters to subroutines
identity<value_a>;
identity<value_b>;

// they can be returned from subroutines
using y = identity<value_a>::result;
using z = identity<value_b>::result;

// ... while still maintaining their identity
assert(std::is_same_v<value_a, y>, "");
assert(std::is_same_v<value_b, z>, "");
// and still being distinguishable
assert(!std::is_same_v<y, z>, "");
\end{minted}


On the other hand a namespace, a typedef or a template parameter do not have
some or any of these properties.

\begin{minted}{cpp}
namespace std { }
namespace foo = std;
using bar = unsigned;
using baz = unsigned;

// the are not distinguishable
std::is_same_v<bar, baz>;
std::is_same_v<identity<bar>, identity<baz>>;
// or not even comparable
std::is_same_v<std, foo>;

template <typename Param>
struct identity
{
	typedef Param result;
};

// or they cannot be passed as arguments
identity<std>;
identity<foo>;

// nor returned as a result
namespace y = identity<foo>::result;
\end{minted}

From the above follows, that a {\em second-class object} is everything else that
is not a first-class object.

\subsubsection{Reification}
\label{term-reification}

Generally speaking {\em reification} or \say{thingification}\footnote{From latin \say{rei}, the dative form of \say{res} -- a thing.}, is making something
real, bringing it into being as an entity with its own identity,
or making something concrete.

In regard to programming languages, reification is often defined as making
a concept in the language a first-class object. So in the context of C++ template
metaprogramming a type is reified, but a namespace or a specifier is not.

